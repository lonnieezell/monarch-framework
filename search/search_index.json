{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#monarch-web-framework","title":"Monarch Web Framework","text":"<p>Monarch is an exploration of how simple and flexible a small PHP framework can be.</p> <p>Its goal is to provide the minimum amount of tools and structure to help you create a web application, while providing a structure that is easy to understand and maintain. If you are looking for a framework that is compatible with all modern PSR standards, and follows all the latest trends in web development, Monarch is not for you. If you are looking for a framework that is simple, easy to understand, that provides simple abstractions only where needed, Monarch may be what you are looking for.</p> <p>At its core, Monarch uses HTMX to provide a dynamic and interactive user experience. Features for working with HTMX are built directly into the Request and Response classes.</p>"},{"location":"#folder-structure","title":"Folder Structure","text":"<p>The following folders are used within Monarch:</p> <pre><code>app/\nconfig/\ndatabase/\npublic/\nroutes/\ntests/\nwritable/\n</code></pre>"},{"location":"#app","title":"app/","text":"<p>The <code>app/</code> folder is where you will place all of your application-specific code that are not a route file or associated control file. This is typically where you will place your models, libraries, and other classes.</p>"},{"location":"#config","title":"config/","text":"<p>Contains all of the configuration files for your application.</p>"},{"location":"#database","title":"database/","text":"<p>This is where you will place all of your database migrations and seeds.</p>"},{"location":"#public","title":"public/","text":"<p>This is the web root of your application. It contains the <code>index.php</code> file that is the entry point for all requests.</p>"},{"location":"#routes","title":"routes/","text":"<p>This is where you will define all of the route files, templates, and controller logic.</p>"},{"location":"#tests","title":"tests/","text":"<p>This holds all of your application's tests.</p>"},{"location":"#writable","title":"writable/","text":"<p>This is where Monarch will write any logs, cache files, or other files that need to be written to. When deploying your application, make sure this folder is writable by the web server.</p>"},{"location":"how_to_build_docs/","title":"How to Build Shield Documentation","text":"<p>We use Material for MkDocs for our documentation. See https://squidfunk.github.io/mkdocs-material/getting-started/.</p>"},{"location":"how_to_build_docs/#requirements","title":"Requirements","text":"<ul> <li>Python3</li> <li>pip</li> </ul>"},{"location":"how_to_build_docs/#installation","title":"Installation","text":"<pre><code>pip3 install mkdocs\npip3 install mkdocs-material\npip3 install mkdocs-git-revision-date-localized-plugin\npip3 install mkdocs-redirects\n</code></pre>"},{"location":"how_to_build_docs/#build-the-docs","title":"Build the Docs","text":"<pre><code>mkdocs build\n</code></pre>"},{"location":"how_to_build_docs/#see-the-docs","title":"See the Docs","text":"<pre><code>mkdocs serve\n</code></pre>"},{"location":"how_to_build_docs/#deploy-manually","title":"Deploy Manually","text":"<p>The documentation is built and deployed automatically by GitHub Actions. But if you need to deploy manually, run the following command:</p> <pre><code>mkdocs gh-deploy\n</code></pre>"},{"location":"core/requests/","title":"Requests","text":"<p>HTTP requests are represented by the <code>Request</code> class. This class provides a simple interface for working with the request data, and provides a few helper methods for common tasks and HTMX integration.</p>"},{"location":"core/requests/#getting-the-request-object","title":"Getting the Request Object","text":"<p>You can get the current request object by calling the <code>instance</code> method on the <code>Request</code> class.</p> <pre><code>$request = \\Monarch\\HTTP\\Request::instance();\n</code></pre> <p>Or you can you use the <code>request()</code> helper function. This is functionally the same as the above code, and returns the singleton instance of the request object.</p> <pre><code>$request = request();\n</code></pre>"},{"location":"core/requests/#getting-the-request-data","title":"Getting the Request Data","text":"<p>Most of the data you will need from the request will be available as read-only properties on the request object. For example, to get the request method, you can use the <code>method</code> property.</p> <pre><code>$method = request()-&gt;method;\n</code></pre> <p>The following properties are available on the request object:</p> <ul> <li><code>uri</code> - The full URI of the request.</li> <li><code>method</code> - The HTTP method of the request.</li> <li><code>scheme</code> - The scheme of the request (http or https).</li> <li><code>host</code> - The host of the request.</li> <li><code>port</code> - The port of the request.</li> <li><code>path</code> - The path of the request.</li> <li><code>query</code> - The query string of the request.</li> <li><code>body</code> - The body of the request.</li> <li><code>headers</code> - An array of headers from the request.</li> <li><code>middleware</code> - An array of middleware that will be run on the request. You will typically not need to access this directly.</li> </ul>"},{"location":"core/requests/#creating-a-request-object","title":"Creating a Request Object","text":"<p>Creation of the request object is typically handled by the framework, but you can create a new request object from the global values if needed.</p> <pre><code>use Monarch\\HTTP\\Request;\n\n$request = Request::createFromGlobals();\n</code></pre> <p>During testing, you can create a request object with specific values.</p> <pre><code>use Monarch\\HTTP\\Request;\n\n$request = RequestFromArray([\n    'method' =&gt; 'GET',\n    'uri' =&gt; 'http://example.com/',\n    'headers' =&gt; [\n        'Content-Type' =&gt; 'text/html',\n    ],\n]);\n</code></pre>"},{"location":"core/requests/#request-as-an-array","title":"Request as an Array","text":"<p>If needed, you can export the request object as an array.</p> <pre><code>$request = request()-&gt;toArray();\n\nprint_r($request);\n// [\n//     'uri' =&gt; 'http://example.com/',\n//     'method' =&gt; 'GET',\n//     'scheme' =&gt; 'http',\n//     'host' =&gt; 'example.com',\n//     'port' =&gt; 80,\n//     'path' =&gt; '/',\n//     'query' =&gt; '',\n//     'body' =&gt; '',\n//     'headers' =&gt; [\n//         'Content-Type' =&gt; 'text/html',\n//     ],\n// ]\n</code></pre>"},{"location":"core/requests/#headers","title":"Headers","text":"<p>Headers can be accessed from the request object as an array. The keys are the header names, and the values are the header values. Note that this is case-sensitive.</p> <pre><code>// Check if header exists\nif (request()-&gt;hasHeader('Content-Type')) {\n    // Do something\n}\n\n// Get the value of a single header\n$contentType = request()-&gt;header('Content-Type');\n\n// Get all headers as an array\n$headers = request()-&gt;headers();\n</code></pre>"},{"location":"core/requests/#htmx-integration","title":"HTMX Integration","text":"<p>Monarch provides a simple way to work with HTMX requests. You can check all of the HTMX headers with the following built in methods:</p> <pre><code>// Check if the request is an HTMX request\nif (request()-&gt;isHtmx()) {\n    // Do something\n}\n\n// Return the current HTMX Url\n$url = request()-&gt;currentHtmxUrl();\n\n// Check whether the request is for history restoration\n// after a miss in the local history cache\nif (request()-&gt;isHistoryRestore()) {\n    // Do something\n}\n\n// Check if this is a request for a boosted link\nif (request()-&gt;isBoosted()) {\n    // Do something\n}\n\n// Check whether the request was intitiated by an HTMX prompt\nif (request()-&gt;isPrompt()) {\n    // Do something\n}\n\n// Returns the target of the HTMX request\n$target = request()-&gt;target();\n\n// Returns the ID of the element that triggered the HTMX request\n$trigger = request()-&gt;trigger();\n\n// Returns the name of the element that triggered the HTMX request\n$name = request()-&gt;triggerName();\n</code></pre>"},{"location":"core/responses/","title":"Responses","text":"<p>Since Monarch is designed around returning either HTML or JSON responses, it's important to understand how responses are generated and what you can do with them.</p>"},{"location":"core/responses/#html-responses","title":"HTML Responses","text":"<p>HTML responses are automatically generated by rendering the appropriate route file. The resulting HTML is added to the <code>Monarch\\HTTP\\Response</code> object and sent to the client. It is not sent immediately to allow for additional headers to be added, or any modifications that middleware might make. This helps avoid <code>headers already sent</code> errors.</p> <p>The response object is a singleton, so you can access it from anywhere in your application.</p> <pre><code>$response = \\Monarch\\HTTP\\Response::instance();\n</code></pre> <p>Or you can you use the <code>response()</code> helper function. This is functionally the same as the above code, and returns the singleton instance of the response object.</p> <pre><code>$response = response();\n</code></pre>"},{"location":"core/responses/#setting-the-response-body","title":"Setting the response body","text":"<p>If you need to manually set the response body, you can do so by calling the <code>withBody</code> method on the response object. This is most frequently used within the middleware.</p> <pre><code>\\Monarch\\HTTP\\Response::instance()-&gt;withBody('Hello, World!');\n</code></pre>"},{"location":"core/responses/#getting-the-response-body","title":"Getting the response body","text":"<p>You can retrieve the body of the response by calling the <code>body</code> method.</p> <pre><code>$body = \\Monarch\\HTTP\\Response::instance()-&gt;body();\n</code></pre>"},{"location":"core/responses/#headers","title":"Headers","text":"<p>Headers can be added to the response by calling the <code>withHeader</code> method on the response object. This method takes a Monarch\\HTTP\\Header object as its only argument.</p> <pre><code>use Monarch\\HTTP\\Header;\n\nresponse()-&gt;withHeader(new Header('Content-Type', 'text/html'));\n</code></pre> <p>If you add the same header multiple times you will get multiple headers with the same name. If you want to replace a header with the same name, you can use the <code>replaceHeader</code> method.</p> <pre><code>use Monarch\\HTTP\\Header;\n\nresponse()-&gt;replaceHeader(new Header('Content-Type', 'text/html'));\n</code></pre> <p>It will located the header with the same name and replace it with the new header.</p>"},{"location":"core/responses/#forgetting-headers","title":"Forgetting Headers","text":"<p>If you need to remove a header from the response, you can use the <code>forgetHeader</code> method. It takes the header name as the only argument. If multiple headers with the same name exist, they will all be removed.</p> <pre><code>response()-&gt;forgetHeader('Content-Type');\n</code></pre>"},{"location":"core/responses/#getting-headers","title":"Getting Headers","text":"<p>You can retrieve all headers by calling the <code>headers</code> method. This will return an array of Monarch\\HTTP\\Header objects.</p> <pre><code>$headers = response()-&gt;headers();\n</code></pre>"},{"location":"core/responses/#cookies","title":"Cookies","text":"<p>Cookies can be added to the response by calling the <code>withCookie</code> method on the response object. This method takes a Monarch\\HTTP\\Cookie object as its only argument.</p> <pre><code>use Monarch\\HTTP\\Cookie;\n\nresponse()-&gt;withCookie(new Cookie(\n    name: 'name',\n    value: 'value',\n    expires: time() + 3600,\n    path: '/',\n    domain: 'example.com',\n    secure: true,\n    httpOnly: true\n));\n</code></pre> <p>If you add the same cookie multiple times it will overwrite the previous cookie with the same name.</p>"},{"location":"core/responses/#forgetting-cookies","title":"Forgetting Cookies","text":"<p>If you need to remove a cookie from the response, you can use the <code>forgetCookie</code> method. It takes the cookie name as the only argument.</p> <pre><code>response()-&gt;forgetCookie('name');\n</code></pre>"},{"location":"core/responses/#out-of-bound-swaps","title":"Out of Bound Swaps","text":"<p>Out of Bound swaps are an HTMX feature that allows you to \"piggyback\" one or more additional responses on the main response. This is useful for updating multiple parts of the page with a single response.</p> <p>For example, if you had a div in the HTML already on the client's browser, it must have an id attribute.</p> <pre><code>&lt;div id=\"alerts\"&gt;&lt;/div&gt;\n</code></pre> <p>In your response, you might need to send back an alert message to display in the div. You can do this by adding an <code>hx-swap-oob</code> attribute to the div in your response. This element must also have a matching <code>id</code> attribute to the div on the client.</p> <pre><code>&lt;div id=\"alerts\" hx-swap-oob=\"true\"&gt;\n    &lt;p&gt;Alert message here&lt;/p&gt;\n&lt;/div&gt;\n</code></pre> <p>While you can handle that yourself within the route or control file, the Request object allows you to add out of bound swaps to the response from anywhere in your application. This could be useful for adding alerts or notifications from custom code or middleware.</p> <p>You can add an out of bound swap to the response by calling the <code>withSwap</code> method on the response object. This method takes the id of the element to swap and the value to swap it with.</p> <p>Note</p> <p>The value must be a string of HTML.</p> <p>Info</p> <p>While not necessary, the id typically matches the id of the element on the client. It is only used as a reference to be able to remove the swap if needed.</p> <pre><code>use Monarch\\HTTP\\OOBSwap;\n\n$alerts =&lt;&lt;&lt;HTML\n&lt;div id=\"alerts\" hx-swap-oob=\"true\"&gt;\n    &lt;p&gt;Alert message here&lt;/p&gt;\n&lt;/div&gt;\nHTML;\n\nresponse()-&gt;withSwap(\n    id: 'alerts',\n    value: $alerts,\n);\n</code></pre> <p>The swaps are stored in the response object and are sent to the client when the response is sent. If a closing <code>&lt;/body&gt;</code> tag is found in the response body, the swaps are inserted before it. If not, they are appended to the end of the response body.</p>"},{"location":"core/responses/#forgetting-swaps","title":"Forgetting Swaps","text":"<p>If you need to remove a swap from the response, you can use the <code>forgetSwap</code> method. It takes the id of the swap as the only argument.</p> <pre><code>response()-&gt;forgetSwap('alerts');\n</code></pre>"},{"location":"core/routes/","title":"Routes","text":"<p>Routing a URI to the code that should execute it is a fundamental part of any web application. In Monarch, routes are defined using a folder-based approach. Each URI is directly associated with a route file. The route file is a file that determines what happens when a user visits a specific URI.</p> <p>An example folder structure might look like this:</p> <pre><code>routes/\n   about.php\n   index.php\n   blog/\n      index.php\n      post[id].php\n      archive[year][month].php\n</code></pre> <p>In this example, the <code>index.php</code> file would be responsible for handling the <code>/</code> URI. The <code>about.php</code> file would handle the <code>/about</code> URI. The <code>blog/index.php</code> file would handle the <code>/blog</code> URI, and the <code>blog/post[id].php</code> file would handle the <code>/blog/post/123</code> URI.</p>"},{"location":"core/routes/#layouts","title":"Layouts","text":"<p>Special Layout files can be used to define the structure of a page. To define a master layout file to be used on all web files, create a file within the <code>routes</code> folder called <code>+layout.php</code>.</p> <pre><code>routes/\n   +layout.php\n   home.php\n</code></pre> <p>The <code>+layout.php</code> file defines the HTML structure of the page. It should include the <code>&lt;?= $content ?&gt;</code> tag to indicate where the content of the page should be placed.</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n    &lt;title&gt;My Site&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;header&gt;\n        &lt;h1&gt;My Site&lt;/h1&gt;\n    &lt;/header&gt;\n    &lt;main&gt;\n        &lt;?= $content ?&gt;\n    &lt;/main&gt;\n    &lt;footer&gt;\n        &amp;copy; 2021 My Site\n    &lt;/footer&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>"},{"location":"core/routes/#nested-layouts","title":"Nested Layouts","text":"<p>If a subfolder contains a <code>+layout.php</code> file, it will be inserted into the parent layout file. There is no maximum depth to the nesting of the layout files. All web files at that folder level will use the combined layout files. See the views documentation for more detailed information.</p>"},{"location":"core/routes/#route-types","title":"Route Types","text":"<p>By default, Monarch supports the following route types:</p> <ul> <li>Web pages</li> <li>Web page fragments</li> <li>Rest API endpoints</li> <li>Markdown content</li> </ul> <p>Route types are defined within the <code>app/config/routes.php</code> file.</p> <p>Route types are determined based on the route files' extension. The default route files are:</p> <ul> <li><code>.php</code> for web pages</li> <li><code>-{name}.php</code> for fragments</li> <li><code>.api.php</code> for Rest API endpoints</li> <li><code>.md</code> for Markdown files.</li> </ul>"},{"location":"core/routes/#errors","title":"Errors","text":"<p>If a route file ends up throwing an error, the default error page found at <code>/+error.php</code> will be displayed to the user.</p> <p>You can customize the main file to change the look of the error page. You can also create custom error pages within each of the route folders to customize the error page for that specific route.</p>"},{"location":"core/routes/#control-files","title":"Control Files","text":"<p>Control files are used to define the logic for a route. They are optional, and are only needed if you need to do more than just display a basic page.</p> <p>Control files are named the same as the route file, but with a <code>.control.php</code> extension. For example, the <code>about.php</code> route file would use the <code>about.control.php</code> control file.</p> <p>Within each control file, you can define an anonymous class that has methods that match the HTTP verbs you want to handle. For example, to handle a <code>GET</code> request, you would define a <code>get()</code> method. To handle a <code>POST</code> request, you would define a <code>post()</code> method.</p> <pre><code>&lt;?php\n\nreturn new class()\n{\n    public function get(): string\n    {\n        return 'Hello, World!';\n    }\n}\n</code></pre> <p>If the method returns a string, it will be made available to the route file as the <code>$content</code> variable. If it returns any other data type, it will be provided to the route file as the <code>$data</code> variable.</p> <p>If you need to provide both the <code>$content</code> and <code>$data</code> variables, you can return an array with the <code>content</code> and <code>data</code> keys.</p> <pre><code>&lt;?php\n\nreturn new class()\n{\n    public function get(): array\n    {\n        return [\n            'content' =&gt; 'Hello, World!',\n            'data' =&gt; [1, 2, 3],\n        ];\n    }\n}\n</code></pre>"},{"location":"core/routes/#dynamic-routes","title":"Dynamic Routes","text":"<p>Dynamic routes are routes that contain variables within the URI. For example, a route that handles a blog post might look like this:</p> <pre><code>routes/\n   blog/\n      post[id].php\n</code></pre> <p>In this example, the <code>post[id].php</code> file would handle the <code>/blog/post/123</code> URI. The <code>id</code> variable would be available within the control file as a parameter.</p> <pre><code>&lt;?php\n\nreturn new class()\n{\n    public function get(int $id): string\n    {\n        return 'The post ID is: ' . $id;\n    }\n}\n</code></pre> <p>You many include as many dynamic variables as you need within the route file. They will be passed to the control file in the order they are defined.</p>"},{"location":"core/routes/#api-routes","title":"API Routes","text":"<p>API routes are similar to control files, but they are designed to return JSON data instead of HTML content. API routes are defined by using the <code>.api.php</code> extension. The class should extend the <code>Monarch\\API</code> class, which provides helper methods for responding to API requests and handling errors.</p> <pre><code>&lt;?php\n\nuse Monarch\\API;\n\nreturn new class() extends API\n{\n    public function get(): array\n    {\n        return $this-&gt;respond([\n            'message' =&gt; 'Hello, World!',\n        ]);\n    }\n}\n</code></pre> <p>Like control routes, API routes should have methods that match the HTTP verbs you want to handle. Any data returned must be either null or an array that can be converted to JSON.</p>"},{"location":"core/routes/#response-methods","title":"Response Methods","text":"<p>API routes have access to the following response methods:</p> <ul> <li><code>respond(array $data): array</code> - Respond with a JSON object.</li> <li><code>withStatus(int $status ?string $message=null): self</code> - Set the status code of the response.</li> </ul> <pre><code>public function get()\n{\n    return $this-&gt;respond([\n        'message' =&gt; 'Resource created',\n    ])-&gt;withStatus(200);\n}\n</code></pre> <ul> <li><code>fail(?string $description=null)</code> - Respond with an error message. If a description is provided, it will be included in the response, otherwise the message will be \"Unknown Error\". The response also includes the timestamp of the error, the status code, and the URI path that caused the error.</li> </ul> <pre><code>public function get()\n{\n    $resource = $this-&gt;getResource();\n\n    if (! $resource) {\n        return $this-&gt;fail('Resource not found');\n    }\n}\n\n// Returns the following JSON:\n{\n    \"error\": \"Resource not found\",\n    \"message\": \"Resource not found\",\n    \"timestamp\": \"2021-10-01 12:00:00\",\n    \"status\": 404,\n    \"path\": \"/api/resource/123\"\n}\n</code></pre> <ul> <li><code>respondCreated(array $body, ?string $message = null)</code> - Respond with a 201 status code and a JSON object. The body of the response is the data provided in the <code>$body</code> parameter. If a message is provided, it will be included in the response.</li> </ul> <pre><code>public function post()\n{\n    $resource = $this-&gt;createResource();\n\n    return $this-&gt;respondCreated($resource, 'Resource created');\n}\n</code></pre> <ul> <li><code>respondDeleted(array $body, ?string $message = null)</code> - Respond with a 200 status code and a JSON object. The body of the response is the data provided in the <code>$body</code> parameter. If a message is provided, it will be included in the response.</li> </ul> <pre><code>public function delete()\n{\n    $resource = $this-&gt;deleteResource();\n\n    return $this-&gt;respondDeleted($resource, 'Resource deleted');\n}\n</code></pre> <ul> <li><code>respondUpdated(array $body, ?string $message = null)</code> - Respond with a 200 status code and a JSON object. The body of the response is the data provided in the <code>$body</code> parameter. If a message is provided, it will be included in the response.</li> </ul> <pre><code>public function put()\n{\n    $resource = $this-&gt;updateResource();\n\n    return $this-&gt;respondUpdated($resource, 'Resource updated');\n}\n</code></pre> <ul> <li><code>respondNoContent(?string $message = null)</code> - Respond with a 204 status code and no content. If a message is provided, it will be included in the response.</li> </ul> <pre><code>public function delete()\n{\n    $this-&gt;deleteResource();\n\n    return $this-&gt;respondNoContent('Resource deleted');\n}\n</code></pre> <ul> <li><code>failUnauthorized(?string $error = null)</code> - Respond with a 401 status code and an error message. If an error string is provided, it will be included in the response, otherwise the message will be \"Unauthorized\".</li> </ul> <pre><code>public function get()\n{\n    if (! $this-&gt;isAuthorized()) {\n        return $this-&gt;failUnauthorized('Unauthorized');\n    }\n}\n</code></pre> <ul> <li><code>failForbidden(?string $error = null)</code> - Respond with a 403 status code and an error message. If an error string is provided, it will be included in the response, otherwise the message will be \"Forbidden\".</li> </ul> <pre><code>public function get()\n{\n    if (! $this-&gt;isAuthorized()) {\n        return $this-&gt;failForbidden('Forbidden');\n    }\n}\n</code></pre> <ul> <li><code>failNotFound(?string $error = null)</code> - Respond with a 404 status code and an error message. If an error string is provided, it will be included in the response, otherwise the message will be \"Not Found\".</li> </ul> <pre><code>public function get()\n{\n    $resource = $this-&gt;getResource();\n\n    if (! $resource) {\n        return $this-&gt;failNotFound('Resource not found');\n    }\n}\n</code></pre> <ul> <li><code>failValidationError(string $error = 'Bad Request')</code> - Respond with a 400 status code and an error message. If an error string is provided, it will be included in the response, otherwise the message will be \"Bad Request\". Used when the data provided by the client cannot be validated.</li> </ul> <pre><code>public function post()\n{\n    $data = $this-&gt;getRequestData();\n\n    if (! $this-&gt;validateData($data)) {\n        return $this-&gt;failValidationError('Invalid data');\n    }\n}\n</code></pre> <ul> <li><code>failValidationErrors(array $errors)</code> - Respond with a 400 status code and an array of error messages. The error message is a JSON object that contains the errors provided in the <code>$errors</code> parameter. Used when the data provided by the client cannot be validated for one or more fields.</li> </ul> <pre><code>public function post()\n{\n    $errors = $this-&gt;validateData($data);\n\n    if ($errors) {\n        return $this-&gt;failValidationErrors($errors);\n    }\n}\n</code></pre> <ul> <li><code>failResourceExists(string $description = 'Conflict')</code> - Respond with a 409 status code and an error message. If an error string is provided, it will be included in the response, otherwise the message will be \"Conflict\". Used when the resource already exists and cannot be created.</li> </ul> <pre><code>public function post()\n{\n    $resource = $this-&gt;getResource();\n\n    if ($resource) {\n        return $this-&gt;failResourceExists('Resource already exists');\n    }\n}\n</code></pre> <ul> <li><code>failResourceGone(string $description = 'Gone')</code> - Respond with a 410 status code and an error message. If an error string is provided, it will be included in the response, otherwise the message will be \"Gone\". Used when the resource has been deleted and cannot be accessed.</li> </ul> <pre><code>public function get()\n{\n    $resource = $this-&gt;getResource();\n\n    if (! $resource) {\n        return $this-&gt;failResourceGone('Resource has been deleted');\n    }\n}\n</code></pre> <ul> <li><code>failTooManyRequests(string $description = 'Too Many Requests')</code> - Respond with a 429 status code and an error message. If an error string is provided, it will be included in the response, otherwise the message will be \"Too Many Requests\". Used when the client has sent too many requests in a given amount of time.</li> </ul> <pre><code>public function get()\n{\n    if ($this-&gt;isRateLimited()) {\n        return $this-&gt;failTooManyRequests('Rate limit exceeded');\n    }\n}\n</code></pre>"},{"location":"core/routes/#monarch-routes","title":"Monarch Routes","text":"<p>When the <code>DEBUG</code> constant is set to <code>true</code>, Monarch reserves a set of routes to provide tools for you to use. These all use the <code>_/</code> folder to avoid conflicts with your own routes. You should not use a base folder in your routes folder called <code>_</code> otherwise that will override the Monarch routes.</p>"},{"location":"core/views/","title":"Viewing Routes","text":"<p>While the routes documentation provides a high-level overview of how routes work in Monarch, that information is more geared towards how the routes are found. This document details how the views are combined and displayed to the user.</p>"},{"location":"core/views/#layouts","title":"Layouts","text":"<p>Layouts are special files that define the primary HTML structure of a page that is displayed to the user. They are defined with the file name <code>+layout.php</code>. They must include the <code>&lt;slot&gt;&lt;/slot&gt;</code> tag pair to indicate where the content of the page should be inserted into the layout.</p> <p>Note</p> <p>The page-specific content is generated prior to the layout file being loaded.</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n    &lt;head&gt;\n        &lt;title&gt;Monarch&lt;/title&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;slot&gt;&lt;/slot&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>"},{"location":"core/views/#nested-layouts","title":"Nested Layouts","text":"<p>If a subdirectory contains also contains a <code>+layout.php</code> file, it will be inserted into the parent layout file in the main slot. There is no maximum depth to the nesting of the layout files. However, all layouts must have their own <code>&lt;slot&gt;&lt;/slot&gt;</code> tag pair otherwise the content, or any child layouts, will not be displayed.</p> <p>A root-level layout file might look like this:</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n    &lt;head&gt;\n        &lt;title&gt;Monarch&lt;/title&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;h1&gt;First Layout&lt;/h1&gt;\n        &lt;slot&gt;&lt;/slot&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>In a subdirectory, this layout file also exists.</p> <pre><code>&lt;h2&gt;Second Layout&lt;/h2&gt;\n&lt;slot&gt;&lt;/slot&gt;\n</code></pre> <p>This would result in the following HTML structure:</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n    &lt;head&gt;\n        &lt;title&gt;Monarch&lt;/title&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;h1&gt;First Layout&lt;/h1&gt;\n        &lt;h2&gt;Second Layout&lt;/h2&gt;\n        &lt;slot&gt;&lt;/slot&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>The route file would then be inserted in the second layout's slot.</p>"},{"location":"core/views/#route-types","title":"Route Types","text":"<p>Monarch supports the following route types:</p> <ul> <li>Web pages</li> <li>Web page fragments</li> <li>Rest API endpoints</li> <li>Markdown files displayed as web pages.</li> </ul> <p>Route types are defined within the <code>app/config/routes.php</code> file. The route type is determined based on the routes's file extension.</p>"},{"location":"core/views/#routes-and-layouts","title":"Routes and Layouts","text":"<p>Layout files define the look and basic structure of the page. As such, they are necessary when doing a full page load. However, when loading an HTML fragment, such as a Markdown file or HTML intended to fit into the existing content, the layout file is not needed.</p> <p>When a route is loaded, the system will check and see if the request was made from HTMX. If it was, and it wasn't the result of a boosted link (which wants the full page) then the layout file is not used and the content is returned directly to the browser. If the request was either not made from HTMX or was from a boosted link, then the layout file is used to wrap the content.</p> <p>Rest API routes will never use the layouts.</p>"},{"location":"core/views/#meta-tags","title":"Meta Tags","text":"<p>Every HTML page can have any number of meta tags in the header. These are used for everything from the title and description of the page, to analytics tags. Monarch provides a way to define these tags in the control file or route file.</p> <pre><code>use Monarch\\View\\Meta;\n\n$meta = Meta::instance();\n\n$meta-&gt;setTitle('Monarch');\n$meta-&gt;addMeta([\n    'description' =&gt; 'Monarch is a simple and flexible PHP framework.',\n    'author' =&gt; 'John Doe',\n    'keywords' =&gt; 'PHP, Framework, Monarch',\n]);\n</code></pre> <p>Besides defining meta tags in the control file, the ViewMeta class also provides convenient methods for managing link tags, script, and style tags.</p> <pre><code>$meta-&gt;addLink([\n    'rel' =&gt; 'canonical',\n    'href' =&gt; 'https://example.com/page',\n]);\n$meta-&gt;addScript([\n    'src' =&gt; 'https://example.com/script.js',\n    'type' =&gt; 'text/javascript',\n]);\n$meta-&gt;addStyle([\n    'href' =&gt; 'https://example.com/style.css',\n    'type' =&gt; 'text/css',\n]);\n\n$meta-&gt;addRawScript('console.log(\"Hello, World!\");');\n</code></pre> <p>Markdown files can provide meta tags in the front matter of the file.</p> <pre><code>---\n---\ntitle: A Markdown Route\ndescription: This is a markdown file automatically rendered and displayed as a web page.\nscripts:\n  - src: https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js\n    integrity: sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz\n    crossorigin: anonymous\nstyles:\n  - href: https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css\n    integrity: sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH\n    crossorigin: anonymous\n    rel: stylesheet\n---\n</code></pre>"},{"location":"core/views/#displaying-meta-tags","title":"Displaying Meta Tags","text":"<p>Meta tags are displayed in the layout file using the <code>getMetaTags()</code> method. The types of tags that can be managed and displayed are: <code>title</code>, <code>meta</code>, 'links', <code>scripts</code>, <code>rawScripts</code>, and <code>styles</code>.</p> <pre><code>// &lt;title&gt;Your Page Title&lt;/title&gt;\n&lt;?= Meta::instance()-&gt;output('title') ?&gt;\n\n// &lt;script src=\"https://foo/bar.js\"&gt;&lt;/script&gt;\n&lt;?= Meta::instance()-&gt;output('scripts') ?&gt;\n\n// &lt;meta name=\"description\" content=\"Your page description\"&gt;\n&lt;?= Meta::instance()-&gt;output('meta') ?&gt;\n\n// &lt;link rel=\"canonical\" href=\"https://example.com/page\"&gt;\n&lt;?= Meta::instance()-&gt;output('links') ?&gt;\n\n// &lt;style&gt;body { color: red; }&lt;/style&gt;\n&lt;?= Meta::instance()-&gt;output('styles') ?&gt;\n\n// &lt;script&gt;console.log(\"Hello, World!\");&lt;/script&gt;\n&lt;?= Meta::instance()-&gt;output('styles') ?&gt;\n</code></pre>"},{"location":"core/views/#viewmeta-helper-function","title":"viewMeta() Helper Function","text":"<p>Monarch provides a helper function to make it a little nicer to get the ViewMeta instance: <code>viewMeta()</code>. This simply returns the Meta instance.</p> <pre><code>viewMeta()-&gt;addMeta(['description', 'Monarch is a simple and flexible PHP framework.']);\nviewMeta()-&gt;output('meta');\n</code></pre>"},{"location":"core/views/#escaping-user-content","title":"Escaping User Content","text":"<p>When displaying user-generated content, it is important to escape the content to prevent Cross-Site Scripting (XSS) attacks. Monarch provides several helper functions to escape user-contributed content in a context-aware manner. This is a thin wrapper around the excellent Laminas Escaper library.</p>"},{"location":"core/views/#escaping-html","title":"Escaping HTML","text":"<p>The <code>escapeHtml()</code> function escapes general text being output within the HTML body.</p> <pre><code>&lt;?= escapeHtml('&lt;script&gt;alert(\"Hello, World!\");&lt;/script&gt;') ?&gt;\n</code></pre>"},{"location":"core/views/#escaping-html-attributes","title":"Escaping HTML Attributes","text":"<p>The <code>escapeHtmlAttr()</code> function escapes text that is being output as an HTML attribute.</p> <pre><code>&lt;div data-foo=\"&lt;?= escapeHtmlAttr('&lt;script&gt;alert(\"Hello, World!\");&lt;/script&gt;') ?&gt;\"&gt;&lt;/div&gt;\n</code></pre>"},{"location":"core/views/#escaping-javascript","title":"Escaping JavaScript","text":"<p>The <code>escapeJs()</code> function escapes text that is being output within a <code>&lt;script&gt;</code> tag.</p> <pre><code>&lt;script&gt;\n    var foo = &lt;?= escapeJs($foo) ?&gt;;\n&lt;/script&gt;\n</code></pre>"},{"location":"core/views/#escaping-css","title":"Escaping CSS","text":"<p>The <code>escapeCss()</code> function escapes text that is being output within a <code>&lt;style&gt;</code> tag.</p> <pre><code>&lt;style&gt;\n    body {\n        color: &lt;?= escapeCss('red') ?&gt;;\n    }\n&lt;/style&gt;\n</code></pre>"},{"location":"core/views/#escaping-urls","title":"Escaping URLs","text":"<p>The <code>escapeUrl()</code> function escapes text that is being output as part of a URL. It is not necessary to escape the entire URL, only the parts that are user-contributed.</p> <pre><code>&lt;a href=\"http://example.com/?q=&lt;?= escapeUrl($query) ?&gt;\"&gt;Link&lt;/a&gt;\n</code></pre>"},{"location":"database/connections/","title":"Database: Getting Started","text":"<p>Monarch provides a very simple wrapper around the PDO database abstraction layer. This wrapper is designed to be simple and easy to use, while still providing a good level of security and flexibility. Unlike many other database abstraction layers, Monarch does not attempt to hide the underlying database layer, but instead encourages the developer to learn the underlying technology and the SQL language.</p>"},{"location":"database/connections/#configuring-database-connections","title":"Configuring Database Connections","text":"<p>Database connections are configured in the <code>config/database.php</code> file. This file contains an array of database connections, each of which is an array of connection parameters. The <code>default</code> connection defines which connection is used by default, but you can specify a different connection by passing the connection name to the <code>db()</code> method.</p> <pre><code>return [\n    'default' =&gt; 'mysql',\n    'mysql' =&gt; [\n        'driver' =&gt; env('DB_DRIVER_DEFAULT', 'mysql'),\n        'host' =&gt; env('DB_HOST_DEFAULT', 'localhost'),\n        'port' =&gt; env('DB_PORT_DEFAULT', 3306),\n        'user' =&gt; env('DB_USER_DEFAULT', 'root'),\n        'password' =&gt; env('DB_PASSWORD_DEFAULT', 'root'),\n        'database' =&gt; env('DB_DATABASE_DEFAULT', 'app'),\n        'charset' =&gt; 'utf8mb4',\n    ],\n];\n</code></pre> <p>As you can see, the values should be set in the <code>.env</code> file. This allows you to easily switch between different database connections by changing the values in the <code>.env</code> file. This is also much more secure than including it in the <code>config/database.php</code> file itself, since the <code>.env</code> file is not saved as part of the repo.</p>"},{"location":"database/connections/#connecting-to-the-database","title":"Connecting to the Database","text":"<p>Connections happen lazily as they are needed. So, no connection is made until a query is executed. This allows you to define multiple connections in the <code>config/database.php</code> file, but only connect to the database when you need to.</p> <p>If you need to manually connect to the database, you can call the <code>connect()</code> method on the <code>Connection</code> object. This will establish a connection to the database using the connection parameters defined in the <code>config/database.php</code> file.</p> <pre><code>db()-&gt;connect();\n</code></pre>"},{"location":"database/connections/#getting-the-connection-type","title":"Getting the connection type","text":"<p>You can get the connection type by calling the <code>driver()</code> method on the <code>Connection</code> object.</p> <pre><code>$driver = db()-&gt;driver();\n// returns: 'mysql'\n</code></pre>"},{"location":"database/connections/#using-the-database","title":"Using the Database","text":"<p>To use the database, you can call the <code>db()</code> function, which returns a <code>Monarch\\Database\\Connection</code> object. This object provides a simple wrapper around the PDO database abstraction layer, and allows you to execute queries and fetch results.</p> <pre><code>$users = db()-&gt;query('SELECT * FROM users')-&gt;fetchAll();\n</code></pre> <p>This uses the default database connection, runs a query against that connection, and fetches all the results. You can also specify a different connection by passing the connection name as the first argument to the <code>db()</code> function.</p> <pre><code>$users = db('mysql')-&gt;query('SELECT * FROM users')-&gt;fetchAll();\n</code></pre> <p>This will use the <code>mysql</code> connection instead of the default connection.</p> <p>Note</p> <p>The <code>db()</code> function will return a singleton instance of the <code>Connection</code> object for each unique configuration it uses. This means that you can call the <code>db()</code> function multiple times with the same configuration, and it will return the same <code>Connection</code> object each time. This allows you to easily share the same connection between different parts of your application.</p>"},{"location":"database/connections/#pdo-access","title":"PDO Access","text":"<p>If you need to access the underlying PDO object directly, you can do so by grabbing the public <code>pdo</code> instance on the <code>Connection</code> object. This will return the <code>PDO</code> object that is used by the connection.</p> <pre><code>$pdo = db()-&gt;pdo;\n</code></pre> <p>This can be useful if you need to access some of the more advanced features of the PDO object that are not exposed by the <code>Connection</code> object.</p>"},{"location":"database/connections/#error-handling","title":"Error Handling","text":"<p>If an error occurs during the execution of a query, an exception will be thrown. You can catch this exception and handle it as needed.</p> <pre><code>try {\n    $users = db()-&gt;run('SELECT * FROM users')\n        -&gt;fetchAll();\n} catch (Exception $e) {\n    // Handle the error\n}\n</code></pre> <p>This will catch any exceptions that are thrown during the execution of the query, and allow you to handle them gracefully. You can then log the error, display an error message to the user, or take any other action that is appropriate.</p>"},{"location":"database/connections/#table-methods","title":"Table Methods","text":"<p>The database connection provides several methods for working with database tables.</p>"},{"location":"database/connections/#tableexistsstring-table-bool","title":"<code>tableExists(string $table): bool</code>","text":"<p>This method checks if a table exists in the database. It returns <code>true</code> if the table exists, and <code>false</code> if it does not.</p> <pre><code>if (db()-&gt;tableExists('users')) {\n    // The users table exists\n}\n</code></pre>"},{"location":"database/connections/#tables-array","title":"<code>tables(): array</code>","text":"<p>This method returns an array of all the tables in the database.</p> <pre><code>$tables = db()-&gt;tables();\n\n// returns:\n[\n    ['name' =&gt; 'users', 'view' =&gt; false],\n    ['name' =&gt; 'posts', 'view' =&gt; false],\n    ['name' =&gt; 'comments', 'view' =&gt; false],\n]\n</code></pre>"},{"location":"database/connections/#columnsstring-table-array","title":"<code>columns(string $table): array</code>","text":"<p>This method returns an array of all the columns in a table.</p> <pre><code>$columns = db()-&gt;columns('users');\n\n// returns:\n[\n    [\n        'field' =&gt; 'name',\n        'type' =&gt; 'varchar(255)',\n        'null' =&gt; true,\n        'key' =&gt; null,\n        'default' =&gt; null,\n        'extra' =&gt; '',\n    ],\n]\n</code></pre>"},{"location":"database/connections/#columnnamesstring-table-array","title":"<code>columnNames(string $table): array</code>","text":"<p>This method returns an array of the column names in a table.</p> <pre><code>$columns = db()-&gt;columnNames('users');\n\n// returns:\n['name', 'email', 'password']\n</code></pre>"},{"location":"database/connections/#primarykeystring-table-string","title":"<code>primaryKey(string $table): ?string</code>","text":"<p>This method returns the primary key of a table, if one exists.</p> <pre><code>$primaryKey = db()-&gt;primaryKey('users');\n\n// returns:\n'id'\n</code></pre>"},{"location":"database/connections/#createtablestring-table-array-columns-void","title":"<code>createTable(string $table, array $columns): void</code>","text":"<p>This method creates a new table in the database. The first argument is the name of the table, and the second argument is an array of column definitions.</p> <pre><code>db()-&gt;createTable('users', [\n    'id INT AUTO_INCREMENT PRIMARY KEY',\n    'name VARCHAR(255) NOT NULL',\n    'email VARCHAR(255) NOT NULL',\n]);\n</code></pre>"},{"location":"database/connections/#droptablestring-table-void","title":"<code>dropTable(string $table): void</code>","text":"<p>This method drops a table from the database.</p> <pre><code>db()-&gt;dropTable('users');\n</code></pre>"},{"location":"database/connections/#indexesstring-table-array","title":"<code>indexes(string $table): array</code>","text":"<p>This method returns an array of all the indexes in a table.</p> <pre><code>$indexes = db()-&gt;indexes('users');\n\n// returns:\n[\n    ['name' =&gt; 'PRIMARY', 'unique' =&gt; true, 'primary' =&gt; true, 'columns' =&gt; ['id']],\n    ['name' =&gt; 'email', 'unique' =&gt; false, 'primary' =&gt; false, 'columns' =&gt; ['email']],\n]\n</code></pre>"},{"location":"database/connections/#indexexistsstring-table-string-column-bool","title":"<code>indexExists(string $table, string $column): bool</code>","text":"<p>This method checks if an index exists on a column in a table.</p> <pre><code>if (db()-&gt;indexExists('users', 'email')) {\n    // The email index exists\n}\n</code></pre>"},{"location":"database/connections/#foreignkeysstring-table-array","title":"<code>foreignKeys(string $table): array</code>","text":"<p>This method returns an array of all the foreign keys in a table.</p> <pre><code>$foreignKeys = db()-&gt;foreignKeys('users');\n\n// returns:\n[\n    [\n        'name' =&gt; 'users_role_id_foreign',\n        'local' =&gt; 'role_id',\n        'table' =&gt; 'roles',\n        'foreign' =&gt; 'id',\n    ],\n]\n</code></pre>"},{"location":"database/connections/#foreignkeyexistsstring-table-string-column-bool","title":"<code>foreignKeyExists(string $table, string $column): bool</code>","text":"<p>This method checks if a foreign key exists on a column in a table.</p> <pre><code>if (db()-&gt;foreignKeyExists('users', 'role_id')) {\n    // The role_id foreign key exists\n}\n</code></pre>"},{"location":"database/connections/#disableforeignkeyconstraints-void","title":"<code>disableForeignKeyConstraints(): void</code>","text":"<p>This method disables foreign key constraints for the current connection. This is often used in conjunction with <code>enableForeignKeys()</code> to temporarily disable foreign key constraints while making changes to the database.</p> <pre><code>db()-&gt;disableForeignKeys();\n</code></pre>"},{"location":"database/connections/#enableforeignkeys-void","title":"<code>enableForeignKeys(): void</code>","text":"<p>This method enables foreign key constraints for the current connection. This is often used in conjunction with <code>disableForeignKeys()</code> to temporarily disable foreign key constraints while making changes to the database.</p> <pre><code>db()-&gt;enableForeignKeys();\n</code></pre>"},{"location":"database/extending/","title":"Extending the Database","text":"<p>The database package is designed to be easily extended with new methods and functionality. The QueryBuilder is a good example of this. It is a simple, lightweight tool that provides a handful of methods to help you build your queries easily. This section will show you how to extend the database package with your own methods.</p> <p>Extending the database package can be done to provide convenience methods for your application, or to add functionality that is not provided by the core package. For example, you might want to add methods to work with views or stored procedures, or to provide a more convenient way to work with certain types of queries. Or you might find yourself repeating the same code in multiple places and want to encapsulate that code in a method.</p> <p>Extending the database layer happens in two areas: core extensions and query builder extensions.</p>"},{"location":"database/extending/#core-extensions","title":"Core Extensions","text":"<p>Core extensions are methods that are added directly to the <code>Connection</code> class. These methods are available on all instances of the <code>Connection</code> class, and can be accessed fluently.</p> <p>To add a core extension, create a new class that extends <code>Monarch\\Database\\ExtensionInterface</code>. This interface requires you to implement a single method, <code>extend()</code>. This method takes an instance of the <code>Connection</code> class as its only argument. You can then add your methods to the <code>Connection</code> class using the <code>register()</code> method on the connection instance.</p> <p>Here is an example of how the QueryBuilder registers the <code>sql()</code> method:</p> <pre><code>use Monarch\\Database\\Connection;\nuse Monarch\\Database\\ExtensionInterface;\n\nclass QueryBuilder implements ExtensionInterface\n{\n    public static function extend(Connection $connection): void\n    {\n        $connection-&gt;register('sql', fn($sql, $bindings = null) =&gt; new QueryBuilder::instance()-&gt;sql($sql, $bindings));\n    }\n}\n</code></pre> <p>This registers the <code>sql()</code> method on the <code>Connection</code> class, which returns a new instance of the <code>QueryBuilder</code> class. This method can then be accessed fluently on the <code>Connection</code> class. You can add as many methods as you like in this way.</p> <p>Tip</p> <p>It is best practice to provide a single entry point for your extensions, such as the <code>sql()</code> method, to minimize the chances for collisions with other extensions.</p>"},{"location":"database/extending/#query-builder-extensions","title":"Query Builder Extensions","text":"<p>Query builder extensions are methods that are added to the <code>QueryBuilder</code> class. These methods are available on all instances of the <code>QueryBuilder</code> class, and can be accessed fluently.</p> <p>// Finish me....</p>"},{"location":"database/extending/#configuration","title":"Configuration","text":"<p>To let Monarch know about your core extension, you need to add it to the <code>extensions</code> array in the <code>config/database.php</code> file. This array should contain the fully qualified class names of your extensions.</p> <pre><code>return [\n    //\n    'extensions' =&gt; [\n        QueryBuilder::class,\n    ],\n];\n</code></pre> <p>QueryBuilder extensions should be added to the <code>queryBuilderExtensions</code> array in the <code>config/database.php</code> file. This array should contain the fully qualified class names of your extensions.</p> <pre><code>return [\n    //\n    'queryBuilderExtensions' =&gt; [\n        QueryBuilderExtension::class,\n    ],\n];\n</code></pre>"},{"location":"database/migrations/","title":"Migrations","text":"<p>Migrations allow you to easily update your database schema and keep it in sync with your application. They can be committed to your version control system, and easily shared with other developers. Monarch provides a simple and lightweight migration system.</p> <p>Migrations are not reversible</p> <p>Migrations are not reversible. Once a migration has been executed, it cannot be undone. You should be careful when writing migrations, and make sure that they are correct before running them. You should also make sure that you have a backup of your database before running migrations. While some frameworks provide a way to roll back migrations, Monarch does not. This is by design, to keep the framework simple and lightweight. We've also found that, other than during development, rollbacks are rarely needed.</p>"},{"location":"database/migrations/#creating-migrations","title":"Creating Migrations","text":"<p>Migrations are simple SQL files. They are stored in the <code>database/migrations</code> directory. Each migration file should have a unique name, and should contain the SQL queries to update the database schema. The migration files are executed in the order the operating system finds them. It's up to you to ensure that the migrations are executed in the correct order. One way to do this is to prefix the migration files with a timestamp or a version number. For example:</p> <pre><code>database/migrations/20220101120000_create_users_table.sql\ndatabase/migrations/20220101120100_create_posts_table.sql\n</code></pre> <p>or</p> <pre><code>database/migrations/v1_create_users_table.sql\ndatabase/migrations/v2_create_posts_table.sql\n</code></pre> <p>Migrations are discovered within sub-directories of the <code>database/migrations</code> directory. This allows you to group your migrations by app release version, or by feature, for example. The sub-directories are scanned recursively, so you can nest them as deep as you like.</p> <pre><code>database/\n    migrations/\n        v1.0.0/\n            create_users_table.sql\n            create_posts_table.sql\n        v1.1.0/\n            add_email_to_users_table.sql\n</code></pre>"},{"location":"database/migrations/#running-migrations","title":"Running Migrations","text":"<p>To run the migrations, you can use the <code>migrate</code> command. This command will execute all the migrations that have not yet been executed. It will also keep track of which migrations have been executed, so that they are not executed again. You can run the command like this:</p> <pre><code>php console migrate\n</code></pre> <p>This will execute all the migrations in the <code>database/migrations</code> directory, in the order the operating system finds them. If you want to execute only the migrations in a specific sub-directory, you can pass the sub-directory name as an argument:</p> <pre><code>php console migrate v1.0.0\n</code></pre> <p>This will execute only the migrations in the <code>database/migrations/v1.0.0</code> directory.</p> <p>If you want to execute only a specific migration file, you can pass the file name as an argument. The file name must be relative to the <code>database/migrations</code> directory:</p> <pre><code>php console migrate v1.0.0/create_users_table.sql\n</code></pre>"},{"location":"database/migrations/#refreshing-migrations","title":"Refreshing Migrations","text":"<p>If you want to re-run all the migrations, you can use the <code>migrate --fresh</code> command. This command will drop all existing tables, and then re-run all migrations. You can run the command like this:</p> <pre><code>php console migrate --fresh\n\n// or\n\nphp console migrate -F\n</code></pre>"},{"location":"database/migrations/#writing-migrations","title":"Writing Migrations","text":"<p>Migrations are simple SQL files. They should contain the SQL queries to update the database schema. For example:</p> <pre><code>-- database/migrations/create_users_table.sql\nCREATE TABLE users (\n    id INT AUTO_INCREMENT PRIMARY KEY,\n    name VARCHAR(255) NOT NULL,\n    email VARCHAR(255) NOT NULL\n);\n</code></pre>"},{"location":"database/queries/","title":"Running Queries","text":"<p>The <code>Connection</code> class provides a single method for running queries: <code>run()</code>. This method takes a SQL query string as its first argument, and returns a <code>PDOStatement</code> object. You can then use this object to fetch the results of the query.</p> <pre><code>$statement = db()-&gt;run('SELECT * FROM users');\n$users = $statement-&gt;fetchAll();\n</code></pre> <p>This can be simplified by chaining the <code>run()</code> method with the <code>fetchAll()</code> method.</p> <pre><code>$users = db()-&gt;run('SELECT * FROM users')\n    -&gt;fetchAll();\n</code></pre> <p>Many queries will require parameters to be passed in. You can do this by passing an array of parameters as the second argument to the <code>run()</code> method. These parameters will be automatically escaped and quoted, so you don't have to worry about SQL injection attacks.</p> <pre><code>$user = db()-&gt;run('SELECT * FROM users WHERE id = ?', [1])\n    -&gt;fetch();\n\n$users = db()-&gt;run('SELECT * FROM users WHERE role = ? AND status = ?', [\n    'admin',\n    'active'\n])-&gt;fetchAll();\n</code></pre> <p>Query Types Used</p> <p>Behind the scenes, the <code>run()</code> method uses the PDO::query() method to execute the query when no parameters are passed in. When parameters are passed in, it uses the PDO::prepare() method to prepare the query, and then the PDOStatement::execute() method to execute the query with the parameters. This automatically handles escaping and quoting the parameters, so you don't have to worry about SQL injection attacks.</p>"},{"location":"database/queries/#fetching-results","title":"Fetching Results","text":"<p>The <code>PDOStatement</code> object returned by the <code>run()</code> method provides a number of methods for fetching the results of the query. The most common methods are <code>fetch()</code>, <code>fetchAll()</code>, and <code>fetchColumn()</code>.</p> <p>The fetch() method fetches a single row from the result set, and returns it as an associative array.</p> <p><pre><code>$user = db()-&gt;run('SELECT * FROM users WHERE id = ?', [1])\n    -&gt;fetch();\n</code></pre> As well as when you are expecting a single row in the result, this can be used for queries that are expected to return many rows. When called multiple times, it will return the next row each time.</p> <pre><code>$statement = db()-&gt;run('SELECT * FROM users');\nwhile ($user = $statement-&gt;fetch()) {\n    // Do something with the user\n}\n</code></pre> <p>The fetchAll() method fetches all the rows from the result set, and returns them as an array of associative arrays. This loads all results into memory, so it should be used with caution when dealing with large result sets.</p> <pre><code>$users = db()-&gt;run('SELECT * FROM users')\n    -&gt;fetchAll();\n</code></pre> <p>The fetchColumn() method fetches a single column from the result set, and returns it as an array.</p> <pre><code>$names = db()-&gt;run('SELECT name FROM users')\n    -&gt;fetchColumn();\n</code></pre> <p>You can also specify the column number to fetch, starting from 0.</p> <pre><code>$names = db()-&gt;run('SELECT name, email FROM users')\n    -&gt;fetchColumn(1);\n</code></pre>"},{"location":"database/queries/#fetching-results-as-objects","title":"Fetching Results as Objects","text":"<p>You can also fetch the results as objects by passing the class name to the <code>fetch()</code> and <code>fetchAll()</code> methods. This will return an instance of the specified class for each row in the result set.</p> <pre><code>class User\n{\n    public $id;\n    public $name;\n    public $email;\n}\n\n$users = db()-&gt;run('SELECT * FROM users')\n    -&gt;fetchAll(PDO::FETCH_CLASS, User::class);\n</code></pre> <p>This will return an array of <code>User</code> objects, with the properties set to the values from the result set. You can then access the properties of the object as you would with any other object.</p> <pre><code>foreach ($users as $user) {\n    echo $user-&gt;name;\n}\n</code></pre>"},{"location":"database/queries/#fetching-results-as-key-value-pairs","title":"Fetching Results as Key-Value Pairs","text":"<p>You can also fetch the results as key-value pairs by passing the column name to the <code>fetch()</code> and <code>fetchAll()</code> methods. This will return an associative array with the specified column as the key, and the specified column's value as the value.</p> <pre><code>$users = db()-&gt;run('SELECT id, name FROM users')\n    -&gt;fetchAll(PDO::FETCH_KEY_PAIR);\n</code></pre> <p>This will return an array where the keys are the <code>id</code> column, and the values are the <code>name</code> column. You can then access the values by their keys. This only works when fetching exactly two columns.</p> <pre><code>echo $users[1];\n// [1 =&gt; 'John Doe']\n</code></pre>"},{"location":"database/queries/#fetching-results-as-grouped-arrays","title":"Fetching Results as Grouped Arrays","text":"<p>You can also fetch the results as grouped arrays by passing the column name to the <code>fetch()</code> and <code>fetchAll()</code> methods. This will return an associative array with the specified column as the key, and an array of rows with the specified column's value as the value.</p> <pre><code>$users = db()-&gt;run('SELECT role, name, email FROM users')\n    -&gt;fetchAll(PDO::FETCH_GROUP);\n</code></pre> <p>This will return an array where the keys are the <code>role</code> column, and the values are arrays of rows with the same <code>role</code> value. You can then access the values by their keys.</p> <pre><code>[\n    'admin' =&gt; [\n        ['name' =&gt; 'John Doe', 'email' =&gt; 'johndoe@example.com'],\n        ['name' =&gt; 'Jane Doe', 'email' =&gt; 'janedoe@example.com'],\n    ],\n    'user' =&gt; [\n        ['name' =&gt; 'Alice Smith', 'email' =&gt; 'alicesmith@example.com'],\n        ['name' =&gt; 'Bob Jones', 'email' =&gt; 'bobsmith@example.com'],\n    ],\n]\n</code></pre>"},{"location":"database/queries/#inserting-data","title":"Inserting Data","text":"<p>Inserting data into the database is done using the <code>run()</code> method with an <code>INSERT</code> query. You can pass in an associative array of column names and values to insert the data.</p> <pre><code>db()-&gt;run('INSERT INTO users (name, email) VALUES (:name, :email)', [\n    'name' =&gt; 'John Doe',\n    'email' =&gt; 'johndoe@example.com',\n]);\n</code></pre> <p>This will insert a new row into the <code>users</code> table with the specified values. The keys in the associative array are used as the column names, and the values are used as the column values. The values are automatically escaped and quoted, so you don't have to worry about SQL injection attacks.</p> <p>This example uses named placeholders, which are more readable and easier to maintain than positional placeholders, but can occasionally make things a little more challenging. Named placeholders are always prefixed with a single colon. You can also use positional placeholders if you prefer.</p> <pre><code>db()-&gt;run('INSERT INTO users (name, email) VALUES (?, ?)', [\n    'John Doe',\n    'johndoe@example.com',\n]);\n</code></pre>"},{"location":"database/queries/#updating-data","title":"Updating Data","text":"<p>Updating data in the database is done using the <code>run()</code> method with an <code>UPDATE</code> query. You can pass in an associative array of column names and values to update the data.</p> <pre><code>db()-&gt;run('UPDATE users SET name = :name, email = :email WHERE id = :id', [\n    'name' =&gt; 'Jane Doe',\n    'email' =&gt; 'janedoe@example.com',\n    'id' =&gt; 1,\n]);\n</code></pre> <p>This will update the row in the <code>users</code> table with the specified values, where the <code>id</code> column matches the specified value. The keys in the associative array are used as the column names, and the values are used as the column values. The values are automatically escaped and quoted, so you don't have to worry about SQL injection attacks.</p>"},{"location":"database/queries/#deleting-data","title":"Deleting Data","text":"<p>Deleting data from the database is done using the <code>run()</code> method with a <code>DELETE</code> query. You can pass in a single value to delete a row by its primary key.</p> <pre><code>db()-&gt;run('DELETE FROM users WHERE id = ?', [1]);\n</code></pre> <p>This will delete the row in the <code>users</code> table where the <code>id</code> column matches the specified value. The value is automatically escaped and quoted.</p>"},{"location":"database/queries/#transactions","title":"Transactions","text":"<p>You can use transactions to group multiple queries together into a single unit of work. This allows you to ensure that all the queries are executed successfully, or none of them are executed at all. This is useful when you need to make sure that a series of queries are executed atomically.</p> <p>To start a transaction, you can call the <code>beginTransaction()</code> method on the <code>Connection-&gt;pdo</code> object. This will start a new transaction on the current connection. You can then run your queries as normal, and they will be executed within the transaction. If any of the queries fail, you can call the <code>rollBack()</code> method to roll back the transaction, and undo all the changes. If all the queries succeed, you can call the <code>commit()</code> method to commit the transaction, and save all the changes.</p> <pre><code>$db = db();\n$db-&gt;pdo-&gt;beginTransaction();\n\ntry {\n    $db-&gt;run('INSERT INTO users (name, email) VALUES (:name, :email)', [\n        'name' =&gt; 'John Doe',\n        'email' =&gt; 'johndoe@example.com'\n    ]);\n\n    $db-&gt;run('INSERT INTO users (name, email) VALUES (:name, :email)', [\n        'name' =&gt; 'Jane Doe',\n        'email' =&gt; 'janedoe@example.com'\n    ]);\n\n    $db-&gt;pdo-&gt;commit();\n} catch (Exception $e) {\n    $db-&gt;pdo-&gt;rollBack();\n    throw $e;\n}\n</code></pre>"},{"location":"database/query_builder/","title":"Query Builder","text":"<p>While Monarch encourages using raw SQL queries, it also acknowledges that sometimes structuring your queries requires several steps. The query builder is a simple, lightweight tool that provides a handful of methods to help you build your queries easily.</p>"},{"location":"database/query_builder/#query-builder-access","title":"Query Builder Access","text":"<p>The query builder can be instantiated by simply creating a new instance of the <code>QueryBuilder</code> class.</p> <pre><code>use Monarch\\Database\\QueryBuilder;\n\n$query = new QueryBuilder();\n</code></pre> <p>Alternatively, it can be accessed fluently within the <code>Connection</code> class, through the <code>sql()</code> method. This method returns a new instance of the <code>QueryBuilder</code> class. The first argument is the SQL string and the second argument is an optional array of parameters. This is the recommended way to access the query builder, unless you have specific needs that require a new instance of the query builder.</p> <pre><code>use Monarch\\Database\\Connection;\n\n$query = db()-&gt;sql('SELECT * FROM users WHERE id = ?', [1])\n    -&gt;fetchAll();\n</code></pre> <p>Either way you choose to access the query builder, the methods available are the same.</p>"},{"location":"database/query_builder/#query-builder-methods","title":"Query Builder Methods","text":"<p>The query builder provides a handful of methods to help you build your queries. These methods are chainable, so you can call them one after the other. The methods are as follows:</p>"},{"location":"database/query_builder/#concat","title":"<code>concat()</code>","text":"<p>The <code>concat()</code> method allows you to add another string to the SQL query. This might be used to add a <code>WHERE</code> clause, for example, or to add more after using the other methods, or simply to aid in readability.</p> <pre><code>$query = db()\n    -&gt;sql('SELECT * FROM users WHERE id = ?', [1])\n    -&gt;concat(' AND name = ?', ['John'])\n    -&gt;fetchAll();\n</code></pre> <p>This can be chained as many times as needed. Each call to <code>concat()</code> will add the string to the end of the query, and the parameters will be added to the array of bound parameters.</p>"},{"location":"database/query_builder/#when","title":"<code>when()</code>","text":"<p>The <code>when()</code> method allows you to conditionally add a string to the SQL query. The first argument must evaluate to a boolean, and the second argument is the string to add if the boolean is true. The third argument is an optional array of parameters to bind. The new SQL will only be added if the first argument evaluates to true.</p> <pre><code>$query = db()\n    -&gt;sql('SELECT * FROM users')\n    -&gt;when($role, ' WHERE role = ?', [$role])\n    -&gt;concat(' AND active = ?', [1])\n    -&gt;fetchAll();\n</code></pre>"},{"location":"database/query_builder/#whennot","title":"<code>whenNot()</code>","text":"<p>The <code>whenNot()</code> method is the opposite of <code>when()</code>. It will only add the string to the SQL query if the first argument evaluates to false.</p> <pre><code>$query = db()\n    -&gt;sql('SELECT * FROM users')\n    -&gt;whenNot($ignoreRole, ' WHERE role = ?', [$role])\n    -&gt;concat(' AND active = ?', [1])\n    -&gt;fetchAll();\n</code></pre>"},{"location":"database/query_builder/#each","title":"<code>each()</code>","text":"<p>The <code>each()</code> method allows you to loop through an array and add a string to the SQL query for each item in the array. The first argument is the array to loop through, and the second argument is a callback function that will be called for each item in the array. The callback function receives the Query Builder instance as the second argument so the other methods can be used to add additional SQL and bound values. It also passes the current $index as the third argument.</p> <pre><code>$query = db()\n    -&gt;sql('SELECT * FROM users')\n    -&gt;each($roles, function($role, $query, $index) {\n        $query-&gt;concat(' OR role = ?', [$role]);\n    });\n    -&gt;fetchAll();\n</code></pre>"},{"location":"database/query_builder/#tosql","title":"<code>toSQL()</code>","text":"<p>The <code>toSQL()</code> method returns the SQL string that has been built so far. This can be useful for debugging purposes, or if you need to pass the SQL string to another method.</p> <pre><code>$sql = db()\n    -&gt;sql('SELECT * FROM users')\n    -&gt;concat(' WHERE id = ?', [1])\n    -&gt;toSQL();\n</code></pre>"},{"location":"database/query_builder/#bindings","title":"<code>bindings()</code>","text":"<p>The <code>bindings()</code> method returns an array of the bound parameters that have been added so far. This can be useful for debugging purposes, or if you need to pass the bound parameters to another method.</p> <pre><code>$query = $sql = db()\n    -&gt;sql('SELECT * FROM users')\n    -&gt;concat(' WHERE id = ?', [1]);\n$sql = $query-&gt;toSQL();\n$bindings = $query-&gt;bindings();\n</code></pre>"},{"location":"database/query_builder/#reset","title":"<code>reset()</code>","text":"<p>The <code>reset()</code> method resets the query builder to its initial state. This can be useful if you need to reuse the query builder for another query, especially during testing.</p> <pre><code>$query = db()\n    -&gt;sql('SELECT * FROM users')\n    -&gt;concat(' WHERE id = ?', [1]);\n$query-&gt;reset();\n</code></pre>"},{"location":"helpers/arr/","title":"Array Helper","text":"<p>The <code>Arr</code> helper class provides a set of static methods for working with Arrays.</p>"},{"location":"helpers/arr/#methods","title":"Methods","text":"<ul> <li>Array Helper</li> <li>Methods</li> <li>get</li> <li>has</li> <li>'pluck'</li> </ul>"},{"location":"helpers/arr/#get","title":"get","text":"<p>The <code>get</code> method retrieves a value from an array using dot notation.</p> <pre><code>use Monarch\\Helpers\\Arr;\n\n$array = ['products' =&gt; ['guitar' =&gt; ['price' =&gt; 100]]];\n$price = Arr::get($array, 'products.guitar.price');\n// 100\n</code></pre>"},{"location":"helpers/arr/#has","title":"has","text":"<p>The <code>has</code> method checks if a given key exists in an array using dot notation.</p> <pre><code>use Monarch\\Helpers\\Arr;\n\n$array = ['products' =&gt; ['guitar' =&gt; ['price' =&gt; 100]]];\n\n$hasGuitar = Arr::has($array, 'products.guitar');\n// true\n\n$hasPrice = Arr::has($array, 'products.guitar.price');\n// true\n</code></pre>"},{"location":"helpers/arr/#pluck","title":"'pluck'","text":"<p>The <code>pluck</code> method retrieves all of the values for a given key from an array using dot notation.</p> <pre><code>use Monarch\\Helpers\\Arr;\n\n$array = [\n    ['product_id' =&gt; 'prod-100', 'name' =&gt; 'Desk'],\n    ['product_id' =&gt; 'prod-200', 'name' =&gt; 'Chair'],\n];\n\n$plucked = Arr::pluck($array, 'name');\n// ['Desk', 'Chair']\n\n$array = [\n    ['user' =&gt; ['name' =&gt; 'John', 'age' =&gt; 26]],\n    ['user' =&gt; ['name' =&gt; 'Jane', 'age' =&gt; 28]],\n];\n\n$plucked = Arr::pluck($array, 'user.name');\n// ['john', 'jane']\n</code></pre> <p>You can also specify a column to use as a custom key for the returned array:</p> <pre><code>$array = [\n    ['user' =&gt; ['id' =&gt; 10, 'name' =&gt; 'John', 'age' =&gt; 26]],\n    ['user' =&gt; ['id' =&gt; 20, 'name' =&gt; 'Jane', 'age' =&gt; 28]],\n];\n\n$plucked = Arr::pluck($array, 'user.name', 'user.id');\n// [10 =&gt; 'John', 20 =&gt; 'Jane']\n</code></pre>"},{"location":"helpers/debugging/","title":"Debugging Tools","text":"<p>Monarch provides a few tools to help you debug your application. As web developers the browser is our playground. The debugging tools take this to heart. Many of them are designed to be used in the browser's console.</p>"},{"location":"helpers/debugging/#monarch-info-panel","title":"Monarch Info Panel","text":"<p>Instead of using a traditional debug bar in the browser window, Monarch uses the browser's <code>console</code> window to display debugging information. This is done to keep the browser window clean and to avoid interfering with the layout of the page. The Monarch info panel is displayed in the console window when an HTML page or fragment is loaded.</p> <p>It displays some basic stats including elapsed time for Monarch to build the page, the peak memory used, whether it's an HTMX request, and route information. It also displays information gleaned from HTMX's request headers, as well as a list of all headers found for the Request, in case that is different than what HTMX sends.</p>"},{"location":"helpers/debugging/#adding-custom-info","title":"Adding Custom Info","text":"<p>You can add custom information to the <code>Basic Stats</code> section of the info panel by using the <code>Monarch\\Debug\\Info</code> class.</p> <pre><code>use Monarch\\Debug\\Info;\n\nInfo::instance()-&gt;add('Custom Label', 'Custom Value');\n</code></pre>"},{"location":"helpers/debugging/#console-logging","title":"Console Logging","text":"<p>The <code>debug()</code> helper function provides a wrapper around many of Javascript's <code>console</code> logging functions. The methods are used within the PHP files, but the logs are displayed in the browser's console. The display has custom styling to make it instantly recognizable as a Monarch log.</p> <pre><code>debug()-&gt;error('Your message');\ndebug()-&gt;info('Your message');\ndebug()-&gt;warn('Your message');\ndebug()-&gt;debug('Your message');\ndebug()-&gt;log('Your message');\n</code></pre> <p>These are the basic logging methods and will output the appropriate log level in the console. The first parameter is the item to display. This can be a string, array, object, or any other type of data. You can also use the second parameter to specify a label for the log. The label will be displayed in the console before the item, surrounded by square brackets. If you are logging an array or object, the label will be displayed on the line above the item, using the \"log\" styling.</p> <pre><code>debug()-&gt;log('Your message', 'Label');\n// [Label] Your message\n</code></pre>"},{"location":"helpers/debugging/#logging-tabular-data","title":"Logging Tabular Data","text":"<p>If you have an array of arrays, you can log it as a table. This is useful for displaying data in a more readable format.</p> <pre><code>$users = [\n    ['name' =&gt; 'John', 'age' =&gt; 26],\n    ['name' =&gt; 'Jane', 'age' =&gt; 28],\n];\n\ndebug()-&gt;table($users);\n</code></pre>"},{"location":"helpers/debugging/#grouping-logs","title":"Grouping Logs","text":"<p>If you have many logs to display you may find that the console becomes cluttered. You can group logs together to keep things organized.  Each group will be collapsible in the console. You specify the group by calling the <code>group</code> method, and then call <code>groupEnd</code> to close the group.</p> <pre><code>debug()-&gt;group('Group Label');\ndebug()-&gt;log('Your message');\ndebug()-&gt;groupEnd();\n</code></pre>"},{"location":"helpers/debugging/#configuring-logging","title":"Configuring Logging","text":"<p>By default, the log items are echoed out at the location that you call the <code>debug()</code> function. You can change this behavior by setting the <code>capture</code> option to <code>true</code> in the <code>debug</code> config file. This will display all of the logs at the end of the page, just prior to the closing <code>&lt;/body&gt;</code> tag. The advantage here is that the script tags that do the logging do not clutter up the HTML source. This does come at a cost of not seeing what line in the generated HTML the log was called from.</p>"},{"location":"helpers/debugging/#local-debugging","title":"Local Debugging","text":"<p>In addition to logging to the browser console, you can also view more information using Kint's <code>d()</code> function or <code>dd()</code>. This will display a more detailed view of the data in the browser window. This is useful for debugging complex data structures.</p> <pre><code>d($data);\ndd($data);\n</code></pre>"},{"location":"helpers/files/","title":"Files","text":""},{"location":"helpers/files/#file-helper","title":"File Helper","text":"<p>The Files helper class contains functions that assist in working with files.</p>"},{"location":"helpers/files/#inpath","title":"<code>in($path)</code>","text":"<p>The <code>in</code> method returns a boolean value indicating whether the given file exists in the specified path.</p> <pre><code>use Monarch\\Helpers\\Files;\n\nif (Files::in('path/to/file.txt')) {\n    echo 'File exists!';\n} else {\n    echo 'File does not exist!';\n}\n</code></pre>"},{"location":"helpers/files/#readpath","title":"<code>read($path)</code>","text":"<p>The <code>read</code> method reads the contents of the specified file and returns it as a string.</p> <pre><code>use Monarch\\Helpers\\Files;\n\n$content = Files::read('path/to/file.txt');\n\necho $content;\n</code></pre>"},{"location":"helpers/files/#writepath-content","title":"<code>write($path, $content)</code>","text":"<p>The <code>write</code> method writes the specified content to the specified file. If the containing directory does not exist, it will attempt to create it.</p> <pre><code>use Monarch\\Helpers\\Files;\n\nFiles::write('path/to/file.txt', 'Hello, world!');\n</code></pre>"},{"location":"helpers/files/#appendpath-content","title":"<code>append($path, $content)</code>","text":"<p>The <code>append</code> method appends the specified content to the specified file.</p> <pre><code>use Monarch\\Helpers\\Files;\n\nFiles::append('path/to/file.txt', 'Hello, world!');\n</code></pre>"},{"location":"helpers/files/#deletepath","title":"<code>delete($path)</code>","text":"<p>The <code>delete</code> method deletes the specified file.</p> <pre><code>use Monarch\\Helpers\\Files;\n\nFiles::delete('path/to/file.txt');\n</code></pre>"},{"location":"helpers/files/#copysource-destination","title":"<code>copy($source, $destination)</code>","text":"<p>The <code>copy</code> method copies the specified file to the specified destination. If the containing directory does not exist, it will attempt to create it. If the destination file already exists, it will be overwritten.</p> <pre><code>use Monarch\\Helpers\\Files;\n\nFiles::copy('path/to/file.txt', 'path/to/destination/file.txt');\n</code></pre>"},{"location":"helpers/files/#movesource-destination","title":"<code>move($source, $destination)</code>","text":"<p>The <code>move</code> method moves the specified file to the specified destination. If the containing directory does not exist, it will attempt to create it. If the destination file already exists, it will be overwritten.</p> <pre><code>use Monarch\\Helpers\\Files;\n\nFiles::move('path/to/file.txt', 'path/to/destination/file.txt');\n</code></pre>"},{"location":"helpers/files/#sizepath","title":"<code>size($path)</code>","text":"<p>The <code>size</code> method returns the size of the specified file in bytes.</p> <pre><code>use Monarch\\Helpers\\Files;\n\n$size = Files::size('path/to/file.txt');\n\necho $size;\n</code></pre>"},{"location":"helpers/files/#readjsonpath","title":"<code>readJson($path)</code>","text":"<p>The <code>readJson</code> method reads the contents of the specified JSON file and returns it as an array.</p> <pre><code>use Monarch\\Helpers\\Files;\n\n$data = Files::readJson('path/to/file.json');\n\nprint_r($data);\n</code></pre>"},{"location":"helpers/files/#writejsonpath-data","title":"<code>writeJson($path, $data)</code>","text":"<p>The <code>writeJson</code> method writes the specified data to the specified JSON file. If the containing directory does not exist, it will attempt to create it.</p> <pre><code>use Monarch\\Helpers\\Files;\n\n$data = ['name' =&gt; 'John Doe', 'age' =&gt; 30];\n\nFiles::writeJson('path/to/file.json', $data);\n</code></pre>"},{"location":"helpers/files/#appendjsonpath-data","title":"<code>appendJson($path, $data)</code>","text":"<p>The <code>appendJson</code> method appends the specified data to the specified JSON file. It uses <code>array_merge</code> to merge the existing data with the new data.</p> <pre><code>use Monarch\\Helpers\\Files;\n\n$data = ['name' =&gt; 'Jane Doe', 'age' =&gt; 25];\n\nFiles::appendJson('path/to/file.json', $data);\n</code></pre>"},{"location":"helpers/files/#deletejsonpath-key","title":"<code>deleteJson($path, $key)</code>","text":"<p>The <code>deleteJson</code> method deletes the specified key from the specified JSON file.</p> <pre><code>use Monarch\\Helpers\\Files;\n\nFiles::deleteJson('path/to/file.json', 'name');\n</code></pre>"},{"location":"helpers/str/","title":"Str Helper","text":"<p>The <code>Str</code> helper class provides a set of static methods to manipulate strings.</p>"},{"location":"helpers/str/#methods","title":"Methods","text":""},{"location":"helpers/str/#pascalstring-value-string","title":"<code>pascal(string $value): string</code>","text":"<p>Convert the given string to PascalCase.</p> <pre><code>use Monarch\\Helpers\\Str;\n\nStr::pascal('foo_bar');\n\n// FooBar\n</code></pre>"},{"location":"helpers/str/#camelstring-value-string","title":"<code>camel(string $value): string</code>","text":"<p>Convert the given string to camelCase.</p> <pre><code>use Monarch\\Helpers\\Str;\n\nStr::camel('foo_bar');\n\n// fooBar\n</code></pre>"},{"location":"helpers/str/#kebabstring-value-string","title":"<code>kebab(string $value): string</code>","text":"<p>Convert the given string to kebab-case.</p> <pre><code>use Monarch\\Helpers\\Str;\n\nStr::kebab('fooBar');\n\n// foo-bar\n</code></pre>"},{"location":"helpers/str/#snakestring-value-string","title":"<code>snake(string $value): string</code>","text":"<p>Convert the given string to snake_case.</p> <pre><code>use Monarch\\Helpers\\Str;\n\nStr::snake('FooBar');\n\n// foo_bar\n</code></pre>"},{"location":"helpers/str/#slugstring-value-string","title":"<code>slug(string $value): string</code>","text":"<p>Convert the given string to a URL friendly slug.</p> <pre><code>use Monarch\\Helpers\\Str;\n\nStr::slug('Foo Bar');\n\n// foo-bar\n</code></pre>"},{"location":"helpers/str/#titlestring-value-string","title":"<code>title(string $value): string</code>","text":"<p>Convert the given string to Title Case.</p> <pre><code>use Monarch\\Helpers\\Str;\n\nStr::title('foo_bar');\n\n// Foo Bar\n</code></pre>"},{"location":"helpers/str/#containsstring-haystack-string-needle-bool","title":"<code>contains(string $haystack, string $needle): bool</code>","text":"<p>Check if the given string contains the given substring.</p> <pre><code>use Monarch\\Helpers\\Str;\n\nStr::contains('foo_bar', 'bar');\n\n// true\n</code></pre>"},{"location":"helpers/str/#containsallstring-haystack-array-needles-bool","title":"<code>containsAll(string $haystack, array $needles): bool</code>","text":"<p>Check if the given string contains all the given substrings.</p> <pre><code>use Monarch\\Helpers\\Str;\n\nStr::containsAll('foo_bar', ['foo', 'bar']);\n\n// true\n</code></pre>"},{"location":"helpers/str/#likestring-pattern-string-value-bool","title":"<code>like(string $pattern, string $value): bool</code>","text":"<p>Check if the given string matches the given pattern. The pattern can contain the following wildcards:</p> <ul> <li><code>%</code> matches zero or more characters</li> <li><code>*</code> matches zero or more characters</li> <li>'?' matches a single character</li> </ul> <p>It returns a boolean value indicating whether the string matches the pattern.</p> <pre><code>use Monarch\\Helpers\\Str;\n\nStr::like('foo*', 'foobar');\n\n// true\n</code></pre>"},{"location":"helpers/str/#lengthstring-value-int","title":"<code>length(string $value): int</code>","text":"<p>Get the length of the given string.</p> <pre><code>use Monarch\\Helpers\\Str;\n\nStr::length('foo_bar');\n\n// 7\n</code></pre>"},{"location":"helpers/str/#limitstring-value-int-limit-string-end-string","title":"<code>limit(string $value, int $limit, string $end = '...'): string</code>","text":"<p>Limit the number of characters in the given string.</p> <pre><code>use Monarch\\Helpers\\Str;\n\nStr::limit('foo_bar', 3);\n\n// foo...\n</code></pre> <p>A custom ending can be provided as the third argument.</p> <pre><code>use Monarch\\Helpers\\Str;\n\nStr::limit('foo_bar', 3, '!!!');\n\n// foo!!!\n</code></pre>"},{"location":"helpers/str/#wordsstring-value-int-words-string-end-string","title":"<code>words(string $value, int $words, string $end = '...'): string</code>","text":"<p>Limit the number of words in the given string.</p> <pre><code>use Monarch\\Helpers\\Str;\n\nStr::words('foo bar baz', 2);\n\n// foo bar...\n</code></pre> <p>A custom ending can be provided as the third argument.</p> <pre><code>use Monarch\\Helpers\\Str;\n\nStr::words('foo bar baz', 2, '!!!');\n\n// foo bar!!!\n</code></pre>"},{"location":"helpers/str/#randomint-length-16-string","title":"<code>random(int $length = 16): string</code>","text":"<p>Generate a random string of the given length in a secure manner.</p> <pre><code>use Monarch\\Helpers\\Str;\n\nStr::random(8);\n\n// 5e7b3a9c\n</code></pre>"},{"location":"using-monarch/csrf_protection/","title":"CSRF Protection","text":"<p>CSRF (Cross-Site Request Forgery) is a type of attack that occurs when a malicious website, email, or program causes a user's web browser to perform an unwanted action on a trusted site for which the user is currently authenticated.</p> <p>Monarch provides a simple CSRF protection mechanism to help prevent these types of attacks. This protection is enabled by default and works by adding a CSRF token to forms and verifying the token on form submission.</p>"},{"location":"using-monarch/csrf_protection/#generating-a-csrf-token","title":"Generating a CSRF Token","text":"<p>To protect your forms from CSRF attacks, you need to generate a CSRF token and include it in your form. Monarch provides a helper function to generate a CSRF token inside a hidden input field:</p> <pre><code>&lt;?= csrfInput() ?&gt;\n// Generates: &lt;input type=\"hidden\" name=\"csrf_token\" value=\"...\"&gt;\n</code></pre> <p>You can further increase the security of the page by locking the CSRF token to the current URI. This will use a second token that is unique to the current page as part of a hash to generate the CSRF token:</p> <pre><code>&lt;?= csrfInput(true) ?&gt;\n</code></pre>"},{"location":"using-monarch/csrf_protection/#manually-generating-a-csrf-token","title":"Manually Generating a CSRF Token","text":"<p>If you need to generate a CSRF token manually, you can use the <code>csrf()</code> function:</p> <pre><code>$response-&gt;withHeader(new Header('X-CSRF-Token', csrf()));\n</code></pre>"},{"location":"using-monarch/csrf_protection/#verifying-a-csrf-token","title":"Verifying a CSRF Token","text":"<p>When a form is submitted within a POST request, the <code>Security</code> middleware will automatically verify the CSRF token. If the token is invalid, the request will be rejected with a <code>403 Forbidden</code> status code and a message will be displayed.</p> <p>If you need to manually verify a CSRF token, you can use the <code>veirfy</code> function of the CSRF class:</p> <pre><code>use Monarch\\HTTP\\CSRF;\n\nif (!CSRF::verify($token) {\n    // Handle invalid CSRF token\n}\n</code></pre>"},{"location":"using-monarch/email/","title":"Email","text":"<p>Monarch provides a simple way to send emails using the <code>Monarch\\Email</code> class. This class is a wrapper around the Laminas Mail library, which provides a simple way to send emails using PHP. It provides transports for sending emails using SMTP, sendmail, Resend, and more.</p>"},{"location":"using-monarch/email/#sending-emails","title":"Sending Emails","text":"<p>To send an email, you can use the <code>Monarch\\Mail</code> class.</p> <pre><code>use Monarch\\Mail\\Mail;\n\nMail::setView('template-name')\n    -&gt;setSubject('Welcome to Monarch')\n    -&gt;addTo('john.doe@example.com', 'John Doe')\n    -&gt;setData([\n        'name' =&gt; 'John Doe',\n        'url' =&gt; 'https://example.com',\n    ])\n    -&gt;send();\n</code></pre> <p>The <code>setView</code> method is used to set the email template that you want to use. The views are expected to be within the <code>app/mail</code> directory. The <code>addTo</code> method is used to set the recipient's email address and name. The <code>setData</code> method is used to pass data to the email template. The <code>send</code> method is used to send the email.</p> <p>The <code>setData</code> method is used to pass data to the email template. This data can be used in the email template to customize the content of the email.</p> <p>Once you have set the view, subject, recipients, and data, you can send the email using the <code>send</code> method. This will send the email using the default transport and the default sender.</p> <p>The <code>setView</code> method must be called first before calling any other methods. This is because the <code>setView</code> method sets returns a singleton instance of the Mail class, and create the underlying Laminas Mail Message object. You then have access to the underlying Laminas Mail Message object to set the subject, recipients, etc, and can access any of the methods provided by the Laminas Mail Message object.</p>"},{"location":"using-monarch/email/#templates","title":"Templates","text":"<p>Monarch provides a set of components to help you build emails that will work across all email clients. These components are designed to be used with the <code>Monarch\\Email</code> class.</p> <p>Unlike the standard components that you might create, all email components are prefixed with <code>m-</code> instead of <code>x-</code>. This is to avoid conflicts with the standard components.</p> <p>A simple email might look like this:</p> <pre><code>&lt;x-slot name=\"title\"&gt;\n    &lt;m-title&gt;Welcome to Monarch&lt;/m-title&gt;\n&lt;/x-slot&gt;\n\n&lt;x-slot name=\"title\"&gt;\n    &lt;m-heading as=\"h1\"&gt;Welcome to Monarch&lt;/m-heading&gt;\n&lt;/x-slot&gt;\n\n&lt;x-slot name=\"body\"&gt;\n    &lt;m-text style=\"margin-bottom: 2em;\"&gt;\n        Thanks for signing up! We are excited to have you on board.\n    &lt;/m-text&gt;\n    &lt;m-button href=\"&lt;?= $url ?&gt;\"&gt;Sign In&lt;/m-button&gt;\n&lt;/x-slot&gt;\n</code></pre>"},{"location":"using-monarch/email/#layouts","title":"Layouts","text":"<p>By default, your email will be wrapped in a layout specified at <code>app/mail/+layout.php</code>. This layout will contain the basic structure of the email, such as the doctype, head, and body tags. You can customize the layout to include any additional styles or scripts that you need. This can also use any of the components to build a basic structure and style.</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;m-html&gt;\n    &lt;m-head&gt;\n        &lt;meta charset=\"UTF-8\"&gt;\n        &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n        &lt;x-slot name=\"title\"&gt;\n            &lt;m-title&gt;Reset Password&lt;/m-title&gt;\n        &lt;/x-slot&gt;\n    &lt;/m-head&gt;\n    &lt;m-body style=\"background-color: #eaeaea;\"&gt;\n        &lt;m-container style=\"background-color: #ffffff; border: 1px solid #c8c8c8; padding: 1rem 2rem;\"&gt;\n            &lt;m-header style=\"\"&gt;\n                &lt;x-slot name=\"header\"&gt;&lt;/x-slot&gt;\n            &lt;/m-header&gt;\n            &lt;x-slot name=\"body\" style=\"padding-top: 2rem;\"&gt;&lt;/x-slot&gt;\n        &lt;/m-container&gt;\n        &lt;x-slot&gt;&lt;/x-slot&gt;\n    &lt;/m-body&gt;\n&lt;/m-html&gt;\n</code></pre> <p>If you want to use a different layout for a specific email, you can use the <code>setLayout</code> method. The file must be located in the <code>app/mail</code> directory.</p> <pre><code>Mail::setView('template-name')\n    -&gt;setLayout('+custom-layout')\n    -&gt;setSubject('Welcome to Monarch')\n    -&gt;addTo('john.doe@example.com', 'John Doe')\n    -&gt;send();\n</code></pre>"},{"location":"using-monarch/email/#available-components","title":"Available Components","text":""},{"location":"using-monarch/email/#m-html","title":"<code>m-html</code>","text":"<p>The root element for the email. This should contain the <code>m-body</code> component. The default attributes are:</p> <ul> <li>dir: ltr</li> <li>lang: en</li> </ul> <pre><code>&lt;m-html&gt;\n    &lt;m-body&gt;\n        &lt;!-- Email content --&gt;\n    &lt;/m-body&gt;\n&lt;/m-html&gt;\n</code></pre>"},{"location":"using-monarch/email/#m-body","title":"<code>m-body</code>","text":"<p>The body of the email. This should contain all of the email content. The body tag has no default styling. You can always add your own styles to the body tag.</p> <pre><code>&lt;m-body style=\"padding: 2rem 4rem;\"&gt;\n    &lt;!-- Email content --&gt;\n&lt;/m-body&gt;\n</code></pre>"},{"location":"using-monarch/email/#m-container","title":"<code>m-container</code>","text":"<p>A container for grouping elements together, constraining the width of the content, and centering the content in the window. The default attributes are:</p> <ul> <li>max-width: 37.5em</li> <li>margin: 0 auto</li> </ul> <p>The container element is a table with a width of 100%. Any styles passed in apply to the table elemtent itself, not the row or cell elements.</p> <pre><code>&lt;m-container&gt;\n    &lt;!-- Email content --&gt;\n&lt;/m-container&gt;\n</code></pre>"},{"location":"using-monarch/email/#m-row","title":"<code>m-row</code>","text":"<p>A row for grouping columns together. This should be used in conjunction with <code>m-column</code> tags. The default attributes are:</p> <ul> <li>border-collapse: collapse</li> </ul> <p>The row compoment is a table and a single row with a width of 100%. Any styles passed in apply to the table row element itself, not the cell elements.</p> <pre><code>&lt;m-row&gt;\n    &lt;!-- Email content --&gt;\n&lt;/m-row&gt;\n</code></pre>"},{"location":"using-monarch/email/#m-column","title":"<code>m-column</code>","text":"<p>A column for grouping content together. This should be used in conjunction with <code>m-row</code> tags. The table cell used in this component does not have any default styling.</p> <pre><code>&lt;m-row&gt;\n    &lt;m-column&gt;\n        &lt;!-- Email content --&gt;\n    &lt;/m-column&gt;\n&lt;/m-row&gt;\n</code></pre>"},{"location":"using-monarch/email/#m-heading","title":"<code>m-heading</code>","text":"<p>A heading element for the email. You can define the heading level using the <code>as</code> attribute.</p> <pre><code>&lt;m-heading as=\"h1\"&gt;Welcome to Monarch&lt;/m-heading&gt;\n</code></pre>"},{"location":"using-monarch/email/#m-text","title":"<code>m-text</code>","text":"<p>A text element for the email. This component is a paragraph element with some basic default styling:</p> <ul> <li>font-size: 14px</li> <li>line-height: 24px</li> <li>margin: 16px 0</li> </ul> <pre><code>&lt;m-text&gt;\n    Thanks for signing up! We are excited to have you on board.\n&lt;/m-text&gt;\n</code></pre>"},{"location":"using-monarch/email/#m-link","title":"<code>m-link</code>","text":"<p>A link element for the email. This component is an anchor element with some basic default styling:</p> <ul> <li>color: #3490dc;</li> <li>text-decoration: none</li> <li>target: _blank</li> </ul> <pre><code>&lt;m-link href=\"https://example.com\"&gt;Click here to learn more&lt;/m-link&gt;\n</code></pre>"},{"location":"using-monarch/email/#m-button","title":"<code>m-button</code>","text":"<p>A button element for the email. This component is an anchor element with some basic default styling:</p> <ul> <li>background-color: #3490dc;</li> <li>color: #ffffff;</li> <li>display: inline-block;</li> <li>line-height: 1.2;</li> <li>max-width: 100%;</li> <li>margin-left: auto;</li> <li>margin-right: auto;</li> </ul> <pre><code>&lt;m-button href=\"https://example.com\"&gt;\n    Click here to learn more\n&lt;/m-button&gt;\n</code></pre> <p>When passing styles to the <code>m-button</code> component, you can use the <code>style</code> attribute to add inline styles to the button element. The padding values must be in a single <code>padding</code> attribute.</p> <pre><code>&lt;m-button href=\"https://example.com\" style=\"padding: 1em 2em;\"&gt;\n    Click here to learn more\n&lt;/m-button&gt;\n</code></pre>"},{"location":"using-monarch/middleware/","title":"Middleware","text":"<p>Middleware is simply code that can run either before or after a request is processed. It can be used to modify the request or response, or to perform some other action, such as rate-limiting, logging, or authentication.</p>"},{"location":"using-monarch/middleware/#writing-middleware","title":"Writing Middleware","text":"<p>Middleware are created as invokable classes that implement the <code>__invoke</code> method. The <code>__invoke</code> method receives the request, response, and the next middleware in the pipeline as arguments. The middleware can then modify the request or response, and optionally call the next middleware in the pipeline.</p> <p>Here is an example of a simple middleware that checks if a user is authenticated:</p> <pre><code>class LoggerMiddleware\n{\n    public function __invoke($request, $response, $next)\n    {\n        // Check if the user is authenticated\n        if (!Auth::check()) {\n            return response()\n                -&gt;withStatus(401);\n        }\n\n        // Call the next middleware in the pipeline\n        return $next($request, $response);\n    }\n}\n</code></pre> <p>As seen the middleware chain can be broken by returning a response object from the middleware. This is useful for implementing authentication, rate limiting, or other checks that should prevent the request from being processed.</p> <p>Your actions can happen either before the next middleware is called, or after. For example, you could log the request before the next middleware is called, or log the response after the next middleware is called.</p> <pre><code>class LoggerMiddleware\n{\n    public function __invoke($request, $response, $next)\n    {\n        // Log the request before the request is processed\n        Log::info('Request received: ' . $request-&gt;url());\n\n        // Call the next middleware in the pipeline\n        $response = $next($request, $response);\n\n        // Log the response after the request is processed\n        Log::info('Response sent: ' . $response-&gt;status());\n\n        return $response;\n    }\n}\n</code></pre>"},{"location":"using-monarch/middleware/#registering-middleware","title":"Registering Middleware","text":"<p>Middleware can be registered in the <code>config/middleware.php</code> file. Middleware is grouped together under an alias. The config class must contain a key with the group name that contains an array of middleware classes that should be run on that request. The order of the middleware in the array is the order in which they will be run.</p> <pre><code>return [\n    // The 'web' group\n    'web' =&gt; [\n        App\\Middleware\\LoggerMiddleware::class,\n        App\\Middleware\\AuthMiddleware::class,\n    ],\n];\n</code></pre> <p>A default group named <code>web</code> is provided that is run on every request. You can create additional groups by adding a new key to the config file.</p> <pre><code>return [\n    // A 'web' group\n    'web' =&gt; [\n        App\\Middleware\\LoggerMiddleware::class,\n        App\\Middleware\\AuthMiddleware::class,\n    ],\n\n    // An 'api' group\n    'api' =&gt; [\n        App\\Middleware\\RateLimitMiddleware::class,\n    ],\n];\n</code></pre>"},{"location":"using-monarch/middleware/#specifying-middleware","title":"Specifying Middleware","text":"<p>By default, the <code>web</code> group is run on every request. You can specify which group of middleware should be run on a route by using the <code>middleware</code> method on the route's control file, if one exists. It takes HTTP request verb as the only argument.</p> <p>The <code>middleware</code> method should return the name of the middleware group that should be run on the request, or an array of middleware classes that should be run on the request.</p> <pre><code>// routes/products.control.php\n&lt;?php\n\nreturn new class()\n{\n    public function get()\n    {\n        //\n    }\n\n    public function post()\n    {\n        //\n    }\n\n    public function middleware(string $method)\n    {\n        return match ($method) {\n            'post' =&gt; [\n                ...config('middleware.web'),\n                App\\Middleware\\LoggerMiddleware::class,\n                App\\Middleware\\AuthMiddleware::class,\n            ],\n            default =&gt; 'web',\n        };\n    }\n}\n</code></pre>"},{"location":"using-monarch/middleware/#skeleton-file","title":"Skeleton File","text":"<p>The following is a skeleton middleware file that can be copied and pasted into your project:</p> <pre><code>&lt;?php\n\nnamespace App\\Middleware;\n\nclass SkeletonMiddleware\n{\n    public function __invoke($request, $response, $next)\n    {\n        //\n\n        return $next($request, $response);\n    }\n}\n</code></pre>"},{"location":"using-monarch/sessions/","title":"Sessions","text":"<p>Sessions are a way to store information (in the form of variables) to be used across multiple pages. This is useful for storing user information, such as their username, or for storing information that needs to be used across multiple pages, such as a shopping cart.</p> <p>Monarch uses the PHP <code>$_SESSION</code> superglobal to store session data. This is a built-in feature of PHP and is used to store session data across multiple pages.</p>"},{"location":"using-monarch/sessions/#choosing-a-session-handler","title":"Choosing a Session Handler","text":"<p>By default, Monarch uses the built-in PHP session handler. This is a file-based session handler that stores session data in files on the server. This is a simple and easy-to-use session handler that works well for most applications when run on a single server.</p> <p>However, if you are running your application on multiple servers, or if you need to store a large amount of session data, you may want to consider using a different session handler. Monarch supports the following session handlers:</p>"},{"location":"using-monarch/sessions/#file-session-handler","title":"File Session Handler","text":"<p>The file session handler stores session data in files on the server. This is the default session handler provided by PHP.</p>"},{"location":"using-monarch/sessions/#sqlite-session-handler","title":"SQLite Session Handler","text":"<p>The SQLite session handler stores session data in an SQLite database. This is a good choice if you need to store a large amount of session data, or if you are running your application on multiple servers, especially when using <code>libSqlite</code> or a distributed provider like Turso.</p> <p>To use the SQLite session handler, you need to set the <code>sessionHandler</code> configuration option to <code>sqlite</code> in your <code>config/app.php</code> file. You also need to provide the location of the database file using the <code>sessionSavePath</code> configuration option. For example:</p> <pre><code>return [\n    'sessionHandler' =&gt; 'sqlite',\n    'sessionSavePath' =&gt; '/path/to/sqlite.db',\n];\n</code></pre> <p>This uses the native SQLite session handler provided by the SQLite extension.</p>"},{"location":"using-monarch/sessions/#redis-session-handler","title":"Redis Session Handler","text":"<p>The Redis session handler stores session data in a Redis database. This is a good choice if you need to store a large amount of session data, or if you are running your application on multiple servers.</p> <p>To use the Redis session handler, you need to set the <code>sessionHandler</code> configuration option to <code>redis</code> in your <code>config/app.php</code> file. You also need to provide the connection details for your Redis server using the <code>sessionSavePath</code> configuration option. For example:</p> <pre><code>return [\n    'sessionHandler' =&gt; 'redis',\n    'sessionSavePath' =&gt; 'tcp://10.133.14.9:6379?auth=yourverycomplexpasswordhere',\n];\n</code></pre> <p>This uses the native session handler provided by the Redis extension.</p>"},{"location":"using-monarch/sessions/#memcached-session-handler","title":"Memcached Session Handler","text":"<p>The Memcached session handler  stores session data in a Memcached server. This is a good choice if you need to store a large amount of session data, or if you are running your application on multiple servers.</p> <p>To use the Memcached session handler, you need to set the <code>sessionHandler</code> configuration option to <code>memcached</code> in your <code>config/app.php</code> file. You also need to provide the connection details for your Memcached server using the <code>sessionSavePath</code> configuration option. For example:</p> <pre><code>return [\n    'sessionHandler' =&gt; 'memcached',\n    'sessionSavePath' =&gt; 'localhost:11211',\n];\n</code></pre> <p>This uses the native session handler provided by the Memcached extension.</p>"},{"location":"using-monarch/validation/","title":"Validation","text":"<p>Monarch provides a validation framework that allows you to validate your data against a set of rules. It is a wrapper around the Somnambulist Validation library, which provides a flexible, Laravel-like validation system, with no dependencies.</p> <p>Tip</p> <p>There are many more details in the Somnambulist Validation documentation about using the library directly and customizing it. This documentation will focus on the Monarch integration and basic usage.</p> <p>Info</p> <p>The validation system is available via the <code>validation()</code> helper function. This function returns an instance of the <code>Validation</code> class. The <code>Validation</code> class is a singleton, so you can use the helper function to access the same instance throughout your application. This is the method these examples will use.</p> <p>If you prefer to use the <code>Validation</code> class directly, you can use the <code>Validation::instance()</code> method to get a singleton instance manually.</p> <pre><code>use Monarch\\Validation;\n\n$validator = Validation::instance();\nValidation::instance()-&gt;make($data, $rules)-&gt;validate();\nValidation::instance()-&gt;errors();\n</code></pre>"},{"location":"using-monarch/validation/#basic-usage","title":"Basic Usage","text":"<p>There are two ways to use the validation system: either the <code>make()</code> or <code>validate</code> methods. The <code>make()</code> method creates a new instance of the validator, and then you'll manually call the <code>validate()</code> method.</p> <pre><code>validation()-&gt;make($_POST + $_FILES, [\n    'name'                  =&gt; 'required',\n    'email'                 =&gt; 'required|email',\n    'password'              =&gt; 'required|min:6',\n    'confirm_password'      =&gt; 'required|same:password',\n    'avatar'                =&gt; 'required|uploaded_file:0,500K,png,jpeg',\n    'skills'                =&gt; 'array',\n    'skills.*.id'           =&gt; 'required|numeric',\n    'skills.*.percentage'   =&gt; 'required|numeric'\n]);\nvalidation()-&gt;validate();\n</code></pre> <p>The second way is to use the <code>validate()</code> method directly. This method will create a new instance of the validator and validate the data in one go.</p> <pre><code>validation()-&gt;validate($_POST + $_FILES, [\n    'name'                  =&gt; 'required',\n    'email'                 =&gt; 'required|email',\n    'password'              =&gt; 'required|min:6',\n    'confirm_password'      =&gt; 'required|same:password',\n    'avatar'                =&gt; 'required|uploaded_file:0,500K,png,jpeg',\n    'skills'                =&gt; 'array',\n    'skills.*.id'           =&gt; 'required|numeric',\n    'skills.*.percentage'   =&gt; 'required|numeric'\n]);\n</code></pre>"},{"location":"using-monarch/validation/#validated-valid-and-invalid-data","title":"Validated, Valid, and Invalid Data","text":"<p>After validating, the <code>validation</code> object contains all of the results.</p> <pre><code>$input = validation()-&gt;validate($_POST + $_FILES, [\n    'title' =&gt; 'required',\n    'body' =&gt; 'required',\n    'published' =&gt; 'default:1|required|in:0,1',\n    'something' =&gt; 'required|numeric'\n]);\n\n// Returns all of the data that was validated\n$validation-&gt;getValidatedData();\n// [\n//     'title' =&gt; 'Lorem Ipsum',\n//     'body' =&gt; 'Lorem ipsum dolor sit amet ...',\n//     'published' =&gt; '1' // notice this\n//     'something' =&gt; '-invalid-'\n// ]\n\n$validation-&gt;getValidData();\n// [\n//     'title' =&gt; 'Lorem Ipsum',\n//     'body' =&gt; 'Lorem ipsum dolor sit amet ...',\n//     'published' =&gt; '1'\n// ]\n\n$validation-&gt;getInvalidData();\n// [\n//     'something' =&gt; '-invalid-'\n// ]\n</code></pre>"},{"location":"using-monarch/validation/#error-messages","title":"Error Messages","text":"<p>Error messages are collected in an <code>ErrorBag</code> instance that you can access via <code>errors()</code> on the validation instance.</p> <pre><code>use Somnambulist\\Components\\Validation\\Factory;\n\n$validation = validation()-&gt;validate($inputs, $rules);\n\n$errors = $validation-&gt;errors();\n</code></pre> <p>The error bag supports the following methods:</p> <pre><code>// Get all errors\n$errors-&gt;all();\n// Get the first message of all existing keys\n$errors-&gt;firstOfAll();\n// Get the first message for a given key\n$errors-&gt;first('key');\n// Get all errors as an associative array\n$errors-&gt;toArray();\n// Count the errors\n$errors-&gt;count();\n// Check if the given key has an error\n$errors-&gt;has('key');\n</code></pre>"},{"location":"using-monarch/validation/#custom-validation-rules","title":"Custom Validation Rules","text":"<p>If you would like to add custom validation rules, you can do so by creating a new rule class as described in the library documentation. Once you have created your rule you can add register it in the <code>config/app.php</code> file.</p> <pre><code>return [\n    ...\n    'validationRules' =&gt; [\n        'custom_rule' =&gt; \\App\\Rules\\CustomRule::class,\n    ],\n];\n</code></pre> <p>Monarch will then ensure that the rule is registered with the underlying library and available for use in your validation rules.</p>"},{"location":"using-monarch/view_components/","title":"Components","text":"<p>As web development has matured, our applications have become more complex. We have moved from simple HTML pages to dynamic web applications that use JavaScript, CSS, and HTML to create rich user experiences. This complexity has led to the development of a new way to organize our code: components.</p> <p>Components are self-contained pieces of code that can be reused across our application. They can be as simple as a button or as complex as a form. Components are a way to encapsulate the logic and presentation of a piece of the user interface. They can be used to create reusable elements that can be shared across different parts of your application.</p> <p>There are two types of components: simple components and controlled components. Simple components are often stateless and are used to render UI elements that do not have any logic requirements. They are often used to help with styling the components using CSS frameworks like TailwindCSS. Controlled components work much like controlled routes, where the component is responsible for managing its own state and rendering the UI based on that state.</p>"},{"location":"using-monarch/view_components/#creating-components","title":"Creating Components","text":"<p>All components should be located within the <code>app/Components</code> directory. This directory is auto-loaded by the framework, so you can reference components by their class name without needing to import them. You can add additional directories to search for components in by adding it to the <code>componentPaths</code> array in the <code>config/app.php</code> file.</p> <pre><code>return [\n    'componentPaths' =&gt; [\n        'x' =&gt; 'app/Components',\n        'x' =&gt; 'app/CustomComponents',\n    ],\n];\n</code></pre> <p>Each component's tag in the HTML will have a prefix of <code>x-</code> to differentiate it from standard HTML tags. This is a convention that Monarch uses to make it clear that a tag is a custom component. You can change the prefix by updating the key of the <code>componentPaths</code> array in the <code>config/app.php</code> file.</p> <pre><code>return [\n    'componentPaths' =&gt; [\n        'my' =&gt; 'app/Components',\n    ],\n];\n</code></pre>"},{"location":"using-monarch/view_components/#simple-components","title":"Simple Components","text":"<p>Simple components consist of a single PHP file that contains the HTML for the component. The file should be located in the <code>app/Components</code> directory and have a name that matches the desired tag name. Note that all custom tags must contain a hyphen (<code>-</code>) to be valid HTML, and Monarch standardizes this by prefixing all custom tags with <code>x-</code>.</p> <p>For example, to create a simple component that renders a button, you would create a file named <code>app/Components/button.php</code> with content similar to this:</p> <pre><code>&lt;button type=\"button\"&gt;\n    &lt;x-slot&gt;&lt;/x-slot&gt;\n&lt;/button&gt;\n</code></pre> <p>Once this file is created, you can use the component in your views like this:</p> <pre><code>&lt;x-button&gt;Click me&lt;/x-button&gt;\n</code></pre> <p>The <code>slot</code> tag is a placeholder that will be replaced with the content inside the component tag.</p>"},{"location":"using-monarch/view_components/#nested-component-folders","title":"Nested Component Folders","text":"<p>You can create nested folders within the <code>app/Components</code> directory to organize your components. For example, if you wanted to create a <code>form</code> component, you could create a folder named <code>form</code> and place the component file inside it. The name of the component would replace the directory separator with a period (.). So <code>form/fieldset</code> would be named <code>x-form.fieldset</code>. The component would then be used like this:</p> <pre><code>&lt;x-form.fieldset&gt;&lt;/x-form.fieldset&gt;\n</code></pre>"},{"location":"using-monarch/view_components/#attributes","title":"Attributes","text":"<p>You can pass attributes to a component by adding them to the component tag. The attributes will be available in the component as an object called <code>$attributes</code>. If echoed out directly, it will be a string of HTML attributes that can be added to the component tag.</p> <pre><code>// app/components/button.php\n&lt;button type=\"button\" class=\"btn btn-primary\" &lt;?= $attributes ?&gt;&gt;\n    &lt;x-slot&gt;&lt;/x-slot&gt;\n&lt;/button&gt;\n</code></pre> <p>You can then use the component like this:</p> <pre><code>&lt;x-button id=\"submit\" name=\"submit\" value=\"Submit\"&gt;Click me&lt;/x-button&gt;\n</code></pre> <p>Attributes can also be accessed individually by using the <code>$attributes-&gt;get()</code> method.</p> <pre><code>// app/components/button.php\n&lt;button\n    type=\"button\"\n    class=\"btn btn-primary\"\n    id=\"&lt;?= $attributes-&gt;get('id') ?&gt;\"\n    &lt;?= $attributes-&gt;except('id', 'class') ?&gt;\n&gt;\n    &lt;x-slot&gt;&lt;/x-slot&gt;\n&lt;/button&gt;\n</code></pre> <p>You can also restrict the attributes that are output by using the <code>only</code> method.</p> <pre><code>// app/components/button.php\n&lt;button\n    type=\"button\"\n    class=\"btn btn-primary\"\n    &lt;?= $attributes-&gt;only('id', 'name') ?&gt;\n&gt;\n    &lt;x-slot&gt;&lt;/x-slot&gt;\n&lt;/button&gt;\n</code></pre>"},{"location":"using-monarch/view_components/#default-merged-attributes","title":"Default / Merged Attributes","text":"<p>Sometimes you may want to provide default attributes for a component that can be overridden by the user. You can do this by merging the default attributes with the user-provided attributes.</p> <pre><code>// app/components/button.php\n&lt;button\n    type=\"button\"\n    &lt;?= $attributes-&gt;merge(['class' =&gt; 'btn btn-primary']) ?&gt;\n&gt;\n    &lt;x-slot&gt;&lt;/x-slot&gt;\n&lt;/button&gt;\n</code></pre> <p>You can then use the component like this:</p> <pre><code>&lt;x-button class=\"btn-lg\"&gt;Click me&lt;/x-button&gt;\n</code></pre> <p>The resulting HTML will be:</p> <pre><code>&lt;button type=\"button\" class=\"btn btn-primary btn-lg\"&gt;Click me&lt;/button&gt;\n</code></pre>"},{"location":"using-monarch/view_components/#dynamic-attributes","title":"Dynamic Attributes","text":"<p>Since the component file is just a PHP file, you can use PHP to generate dynamic attributes.</p> <pre><code>// app/components/button.php\n&lt;?php\n    if ($attributes-&gt;has('disabled')) {\n        $class = 'btn btn-primary btn-disabled';\n    } else {\n        $class = 'btn btn-primary';\n    }\n?&gt;\n\n&lt;button\n    type=\"button\"\n    &lt;?= $attributes-&gt;merge(['class' =&gt; $class]) ?&gt;\n&gt;\n    &lt;x-slot&gt;&lt;/x-slot&gt;\n&lt;/button&gt;\n</code></pre>"},{"location":"using-monarch/view_components/#slots","title":"Slots","text":"<p>As we've seen, slots are a way to pass content into a component. They are placeholders that can be replaced with content when the component is used. Slots are defined using the <code>x-slot</code> tag in the component file and are replaced with the content inside the component tag.</p> <pre><code>&lt;!-- app/components/alert.php --&gt;\n&lt;div class=\"alert alert-&lt;?= $type ?&gt;\"&gt;\n    &lt;x-slot&gt;&lt;/x-slot&gt;\n&lt;/div&gt;\n</code></pre> <p>You can then use the component like this:</p> <pre><code>&lt;x-alert type=\"success\"&gt;\n    &lt;p&gt;Success! Your changes have been saved.&lt;/p&gt;\n&lt;/x-alert&gt;\n</code></pre>"},{"location":"using-monarch/view_components/#default-slot-content","title":"Default Slot Content","text":"<p>You can provide default content for a slot by using the <code>x-slot</code> tag with a default value.</p> <pre><code>&lt;!-- app/components/alert.php --&gt;\n&lt;div class=\"alert alert-&lt;?= $type ?&gt;\"&gt;\n    &lt;x-slot&gt;\n        &lt;p&gt;Default content goes here.&lt;/p&gt;\n    &lt;/x-slot&gt;\n&lt;/div&gt;\n</code></pre> <p>You can then use the component like this:</p> <pre><code>&lt;x-alert type=\"success\"&gt;&lt;/x-alert&gt;\n</code></pre> <p>The default content will be used if no content is provided.</p>"},{"location":"using-monarch/view_components/#named-slots","title":"Named Slots","text":"<p>You can define multiple slots in a component by using the <code>name</code> attribute on the <code>x-slot</code> tag.</p> <pre><code>&lt;!-- app/components/card.php --&gt;\n&lt;div class=\"card\"&gt;\n    &lt;div class=\"card-header\"&gt;\n        &lt;x-slot name=\"header\"&gt;&lt;/x-slot&gt;\n    &lt;/div&gt;\n    &lt;div class=\"card-body\"&gt;\n        &lt;x-slot name=\"body\"&gt;&lt;/x-slot&gt;\n    &lt;/div&gt;\n&lt;/div&gt;\n</code></pre> <p>You can then use the component like this:</p> <pre><code>&lt;x-card&gt;\n    &lt;x-slot name=\"header\"&gt;\n        &lt;h2&gt;Card Title&lt;/h2&gt;\n    &lt;/x-slot&gt;\n    &lt;x-slot name=\"body\"&gt;\n        &lt;p&gt;Card content goes here.&lt;/p&gt;\n    &lt;/x-slot&gt;\n&lt;/x-card&gt;\n</code></pre>"},{"location":"using-monarch/view_components/#controlled-components","title":"Controlled Components","text":"<p>Controlled components are used when you need more logic, or access to more of the framework, than a simple component provides. They are similar to controllers in that they are responsible for managing their own state and rendering the UI based on that state.</p>"},{"location":"using-monarch/view_components/#creating-a-controlled-component","title":"Creating a Controlled Component","text":"<p>Controlled components are PHP classes that extend the <code>Component</code> class. They should be located in the <code>app/components</code> directory and have a name that matches the desired tag name, and have the <code>.control.php</code> extension. You will typically have a corresponding view file with the same name as the component, though it is not required.</p> <p>For example, to create a controlled component that renders a form, you would create a file named <code>app/components/form.control.php</code> with content similar to this:</p> <pre><code>&lt;?php\n\nuse Monarch\\Components\\Component;\n\nreturn new class() extends Component\n{\n    public $name;\n\n    public function render(): string\n    {\n        return $this-&gt;view('form', ['name' =&gt; $this-&gt;name]);\n    }\n}\n</code></pre> <p>You are required to implement the <code>render()</code> method which must return a string. Other than that, you are free to add any additional methods or properties to the class as needed.</p> <p>The class provides a <code>view()</code> method that returns a simple component view like was described earlier in this document. It automatically makes the <code>$attributes</code> object available to the view, and handles parsing any slots. In this case, the <code>form</code> view file would be located at <code>app/Components/form.php</code>.</p>"},{"location":"using-monarch/view_components/#using-a-controlled-component","title":"Using a Controlled Component","text":"<p>Controlled Components are called exactly like simple components, but the control file's <code>render</code> method is called instead of the component file's content being returned.</p> <pre><code>&lt;x-form name=\"contact\"&gt;\n    &lt;x-slot&gt;&lt;/x-slot&gt;\n&lt;/x-form&gt;\n</code></pre> <p>Within the component's control file, you can access the attributes and slots using the <code>$this-&gt;attributes</code> instance.</p> <pre><code>&lt;?php\n\nuse Monarch\\Components\\Component;\n\nreturn new class() extends Component\n{\n    public function render(): string\n    {\n        return $this-&gt;view('form', ['name' =&gt; $this-&gt;attributes-&gt;get('name')]);\n    }\n}\n</code></pre>"}]}